;;; desktop-recover.el ---

;; Copyright 2009 Joseph Brenner
;;
;; Author: doom@kzsu.stanford.edu
;; Version: $Id: desktop-recover.el,v 0.0 2009/07/08 02:59:21 doom Exp $
;; Keywords:
;; X-URL: not distributed yet

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software
;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

;;; Commentary:

;;  Works with the .emacs-desktop files (as generated by desktop.el),
;;  but unlike with desktop-read, provides an interactive menu that
;;  let's the user choose which buffers will be restored.

;; Put this file into your load-path and the following into your ~/.emacs:
;;   (require 'desktop-recover)

;;; Code:

(provide 'desktop-recover)
(eval-when-compile
  (require 'cl))

(require 'desktop)
(require 'thingatpt)



;;======
;; poor man's pod/lazy man's info:
;;   dummy variables with documentation attached

;; TODO add a directory of all of the other *-doc
(defvar desktop-recover-toc-doc ""
  "Several variables are defined here just to have a convenient
place to attach documentation strings:\n

`desktop-recover-desktop-doc'
`desktop-recover-philosophy-doc'
`desktop-recover-dangling-buffers-doc'
`desktop-recover-desktop-list-doc'

")

(defvar desktop-recover-desktop-doc ""
  "In this context the \"desktop\" is the emacs desktop, i.e. the
state of all the current buffers that are open at a given moment,
except for the dynamic buffers \(usually named with a leading
asterix\) and a few other odds and ends.  This is the terminology
used by the package \"desktop.el\" \(already standard with GNU
emacs\).  The package \"desktop-recover.el\" works with
\"desktop.el\", using it for crash recovery purposes \(the sort
of thing people working over flaky network connections have to
deal with\).
See `desktop-recover-toc-doc'.
")  ;; it's also likely that this can
;; be used with project-root to implement project-specific
;; desktops.

(defvar desktop-recover-philosophy-doc ""
  "The general philosophy behind desktop-recover.el.
This code, desktop-recover.el, uses desktop.el internally to save
the state of the emacs \"desktop\", but we very carefully
over-ride or ignore some features of desktop.el.  By
itself, desktop.el is very cautious about keeping desktop files
locked, so that it can warn the user if it looks like two
different emacs instances are trying to use the same file.
Further, it dynamically searches likely locations to find a
desktop file, and makes it a little difficult to over-ride that
behavior (e.g. just setting the `desktop-dirname' variable
doesn't always work).  This package, desktop-recover.el takes
a somewhat different approach: our presumption is that there is
nothing critical about saving desktop state; it's just a
convenience feature, and so there's nothing important enough
about it to want to bother the user about confirmation.
The desktop-recover save primitives ignore the desktop.el locking system:
  \\[desktop-recover-force-save]
  \\[desktop-recover-force-save-in-desktop-dir]
See `desktop-recover-toc-doc'.
")
;; TODO further, (I think)
;; desktop-recover.el uses a much simpler directory search, i.e. it has one
;; default, you set a var to something else if you want something
;; else: `desktop-recover-location'.  You can set this to nil, if you prefer
;; desktop.el's dynamically set desktop-dirname behavior, though it
;; defaults to the "~/.emacs.d" (aka user-emacs-directory)

;; desktop.el sets the desktop-dirname to nil to supress saves,
;; a little less indirectly, the desktop-recover.el save primitives
;; become no-ops if this variable has been set: desktop-recover-suppress-save

(defvar desktop-recover-dangling-buffers-doc ""
  "We use \"dangling buffers\" to mean buffers without associated files.
Typically we will exclude the special display buffers (which
usually begin with an asterix), dired buffers, and so on.  We're
concerned here with buffers used for temporary notes that might've
been prematurely lost by an emacs crash \(e.g. due to a broken connection\).\n
Along with the automated desktop save feature, we will save
these dangling buffers to temporary files, making them a little
less ephemeral, though not as permanent as ordinary files.\n
Nothing else should be saved to this special temp directory,
because we'll use this location later to distinguish dangling
buffers even after they've been saved.  This way
a clean exit from emacs can skip them.
See `desktop-recover-toc-doc'.
")

(defvar desktop-recover-desktop-list-doc ""
  "Many functions in this package work with a data-structure
typically called the \"desktop-list\". This describes the buffers
recorded in the .emacs-desktop file, which are candidates to be
re-loaded when desktop-recover-interactive is run.  The
desktop-list is a list of lists, with one row per buffer, where
each row is a list of (in this order): name, path, mode, and the
desktop-create-buffer call.  The \"name\" is the name sans path,
the \"path\" is the full-name, including path, the mode is the
name of the associated emacs mode (e.g. \"text-mode\"), and the
\"desktop-create-buffer call\" is the code (in string form) that
will need to be run to restore the buffer.
See `desktop-recover-toc-doc'.
")

;;;;##########################################################################
;;;;  User Options, Variables
;;;;##########################################################################

;; defining this first to use it in following defvars, etc.
(defun desktop-recover-fixdir (location &optional root)
  "Fixes up the file directory LOCATION.
Conditions directory paths for portability and robustness.
If the directory does not yet exist, it will be created.\n
Some examples (note, always adds a trailing slash):
 '~/tmp'             => '/home/doom/tmp/'
 '~/tmp/../bin/test' => '/home/bin/test/'\n
Note: converts relative paths to absolute, using the current
default-directory setting, unless specified otherwise with the
ROOT option. As a side-effect: this converts the empty string into
default-directory or ROOT."
  (let ((location
         (substitute-in-file-name
          (convert-standard-filename
           (file-name-as-directory
            (expand-file-name location root))))))
    (unless (file-directory-p location)
      (make-directory location t))
    location))

(defcustom desktop-recover-location user-emacs-directory
  "The default location from which we save and restore desktop files.
Defaults to `user-emacs-directory'.  Note: desktop.el has a
`desktop-dirname' variable, but that can not be used reliably as
a user setting, because the code changes it under some
circumstances.")
(put 'desktop-recover-location 'risky-local-variable t)
(setq desktop-recover-location
      (desktop-recover-fixdir desktop-recover-location))

(defcustom desktop-recover-tmp-dir
  (concat desktop-recover-location "desktop-recover-tmp")
  "Location where dangling buffers that have no associated files are saved.")
(put 'desktop-recover-tmp-dir 'risky-local-variable t)
(setq desktop-recover-tmp-dir
      (desktop-recover-fixdir desktop-recover-tmp-dir))

(defvar desktop-recover-buffer-name "*Desktop Buffer Restore Menu*"
  "Buffer name for the desktop restore menu.")

(defvar desktop-recover-clean-exit-flag "desktop_recover_clean_exit.flag"
  "The existance of a file of this name signals that we did a clean exit.")

(defvar desktop-recover-suppress-save nil
  "Set this to t to over-ride any attempts at doing desktop saves.
Note: this flag is respected by desktop-recover.el code, not desktop.el.")

;; Bound locally in `desktop-read' in desktop.el
(defvar desktop-buffer-ok-count)
(defvar desktop-buffer-fail-count)

;;======================
;; saving desktop files

;; ;; TODO make this reversible.  Use remove-hook.
;; (defun desktop-recover-do-saves-automatically ()
;;   "Makes the desktop saved automatically using the auto-save-hook.
;; It's recommended that you delay doing this until after you've restored
;; the desktop with \\[desktop-recover-interactive]  \(though that
;; routine also sets `desktop-recover-suppress-save' as an additional
;; safety feature\)."
;;   (add-hook 'auto-save-hook
;;             (lambda ()
;;               (desktop-recover-save-with-danglers))))


;; TODO make this reversible.  Use remove-hook.
(defun desktop-recover-do-saves-automatically ()
  "Makes the desktop saved automatically using the auto-save-hook.
It's recommended that you delay doing this until after you've restored
the desktop with \\[desktop-recover-interactive]  \(though that
routine also sets `desktop-recover-suppress-save' as an additional
safety feature\)."
  (add-hook 'auto-save-hook 'desktop-recover-save-with-danglers))



;; TODO ideally: break-out a list of major-modes to be skipped.
(defun desktop-recover-save-with-danglers ()
  "Desktop autosave routine that preserves buffers that have no associated files.
Works by saving them to a standard tmp directory, then using desktop.el to save
them along with the other open files.  After re-starting emacs, you should then
have buffers corresponding to the old dangling buffers (though now they'll be
associated with files in the special tmp location).
See: `desktop-recover-dangling-buffers-doc'"
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (temp-loc desktop-recover-tmp-dir)
         (dangling-buffers (desktop-recover-list-dangling-buffers))
         )
    (unless (file-exists-p temp-loc)
      (make-directory temp-loc t))
    ;; save each to temp location using a file name identical to the buffer name,
    (dolist (buffy dangling-buffers)
            (set-buffer buffy)
            (let* ((buffy-name (buffer-name  buffy))
                   (file-nameo (concat temp-loc "/" buffy-name))
                   )
              (write-file file-nameo) ;; this *is* saving the buffer in the tmp location,
                                      ;; but something is destroying the dangling buffers
              ))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
    ;; (desktop-save-in-desktop-dir)
    ;; (desktop-recover-force-save-in-desktop-dir)
    (desktop-recover-force-save)
  ))

;; Note: used by desktop-recover-save-with-danglers
(defun desktop-recover-list-dangling-buffers ()
  "List buffers without files or directories, skipping internal and display buffers.
Returns a list of buffer objects."
  (interactive)
  (save-excursion
  (let* ((initial-buffer (current-buffer))
         (ordinaries-list (desktop-recover-list-ordinary-buffers))
         (output-list)
         )
    (save-excursion
      (dolist (buffy ordinaries-list)
        (set-buffer buffy) ;; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy) )
               (buffy-name (buffer-name  buffy) )
               )
          (cond ((not file-nameo) ;; looking for buffers without file names
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer initial-buffer)
      (deactivate-mark)
  output-list))))

;; Note: used by desktop-recover-list-dangling-buffers
;; and hence by desktop-recover-save-with-danglers
(defun desktop-recover-list-ordinary-buffers ()
  "List buffers, skips: dired, shell, debugger, internal and display buffers.
Returns a list of buffer objects.  Note that 'ordinary' buffers include
'dangling' buffers without associated files."
  (interactive)
  (let* ((initial-buffer (current-buffer))
         (output-list)
         )
    (save-excursion
      (dolist (buffy (buffer-list))
        (set-buffer buffy) ; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy))
               (buffy-name (buffer-name buffy))
               )
          (cond ((and
                  ;; Skip directories
                  (not (string= major-mode "dired-mode"))
                  ;; Skip internal buffers (begin with space)
                  (not (string= (substring buffy-name 0 1) " "))
                  ;; Skip dynamic display buffers (begin with asterix)
                  (not (string= (substring buffy-name 0 1) "*"))
                  ;; Skip shell and debugger buffers (even without leading "*")
                  (not (or
                        (string= major-mode "shell-mode")
                        (string= major-mode "eshell-mode")
                        (string= major-mode "gud-mode")))
                  )
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer initial-buffer)
      (deactivate-mark)
      output-list)))

(defun desktop-recover-save-buffers-kill-terminal ()
  "Wrapper around save-buffers-kill-terminal to flag clean exits.
Actually, it flags the fact that we *tried* to exit cleanly, since
there's no easy way to check if all saves were completed before
emacs died."
  (interactive)
  (let* ((clean-exit-flag-file
           (concat
            (desktop-recover-fixdir
             desktop-recover-tmp-dir)
            desktop-recover-clean-exit-flag))
         ;; set these to override defaults
         (output-buffer nil)
         (error-buffer  nil)
         (cmd (format "touch %s" clean-exit-flag-file))
         )
    (desktop-recover-save-with-danglers) ;; TODO double-check. right save?
    ;; we do this *after* the above, because that also clears the flag
    (shell-command cmd output-buffer error-buffer)
    (save-buffers-kill-terminal)
    ))


(defun desktop-recover-save-buffers-kill-terminal-exp ()
  "For doing a \"clean\" exit, without need to save danglers.
Essentially a wrapper around save-buffers-kill-terminal, intended
to be bound to the usual keybinding for exiting emacs."
;; TODO alternately, we could do this with the kill-emacs-hook.
;;
;; doing one last desktop save *without* the dangling buffers
;;  (desktop-recover-break-file-association-of-danglers)
;;  (desktop-recover-force-save-in-desktop-dir)
  (desktop-recover-save-without-danglers)
  (save-buffers-kill-terminal)
  )

(defun desktop-recover-break-file-association-of-danglers ()
  "Remove association between dangling buffers and temp files.
We can distinguish between \"real\" buffers and ones that are
dangling-but-saved by the fact that they've been saved to
`desktop-recover-tmp-dir'. See `desktop-recover-dangling-buffers-doc'."
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (temp-loc desktop-recover-tmp-dir)
         (buffers (desktop-recover-list-ordinary-buffers))  ;; includes real danglers, as well as saved ones
         (location)
         (dangling-content-list) ;; list of lists, buffer name paired with content
         )
    ;; breaking file associations of any buffers saved to temp-loc
    (dolist (buffy buffers)
      (setq location (file-name-directory (buffer-file-name buffy)))
      (cond ((string= temp-loc location)
             (set-buffer buffy)
             (let ((name (buffer-name)))
               (set-visited-file-name nil)
               ;; (rename-buffer name) ;; doesn't seem to be necessary
               )
             )))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
  ))

(defun desktop-recover-save-without-danglers ()
  "Desktop autosave routine that skips dangling buffers of any vintage.
This means that it screens out the ones that have been made less ephemeral
by associating them with files in the standard tmp directory.
See: `desktop-recover-dangling-buffers-doc'"
  (interactive)
  (desktop-recover-break-file-association-of-danglers)
  ;; (desktop-recover-force-save-in-desktop-dir)  ;; TODO is this the right "save"?
  (desktop-recover-force-save)
  )

;; --------
;; desktop-recover.el save primitives (all other "saves" use these internally)

;; TODO SOON why don't these primitives explicitly use the var:
;;     desktop-recover-location
;; This should be the default, even if desktop-dirname is set also (maybe for internal reasons)

(defun desktop-recover-force-save (&optional dirname release)
   "Force save of desktop by wiping out any existing file first.
This ensures you will not have any questions getting in the way
about modification times, etc.  If DIRNAME is not given, defaults
to `desktop-recover-location' or the current `desktop-dirname' in
that order.  Passes through RELEASE to \\[desktop-save],
which if t means \"we're done with this desktop\"."
;; Essentially, setting RELEASE deletes the lock file.
;; Should I just do that all the time?
   (let* ((location (desktop-recover-location dirname))
          )
     (cond ((not desktop-recover-suppress-save)
            (setq desktop-dirname (file-name-as-directory (expand-file-name location)))
            (desktop-remove)
            (desktop-save location release)
            )
           (t
            (message "Desktop save skipped, because desktop-recover-suppress-save is set"))
           )))

(defun desktop-recover-location (&optional dirname)
  "The standard behavior for choosing the desktop save location.
If DIRNAME is not given, defaults to `desktop-recover-location'
or the current `desktop-dirname' in that order."
  (or
   dirname
   desktop-recover-location
   desktop-dirname))



;; TODO I don't understand what this is for...
(defun desktop-recover-force-save-in-desktop-dir ()
  "Save the desktop in directory `desktop-dirname'."
  (interactive)
  (cond ((not desktop-recover-suppress-save)
         (if desktop-dirname
             (desktop-recover-force-save desktop-dirname)
           (call-interactively 'desktop-save))
         (message "Desktop saved in %s" (abbreviate-file-name desktop-dirname)))
        (t
         (message "Desktop save skipped, because desktop-recover-suppress-save is set"))
        ))


;; preserving this for now, because I don't understand why it's *still* like this...
(defun desktop-recover-force-save-old (dirname &optional release)
   "Force save of desktop by wiping out any existing file first.
This ensures you will not have any question about modtimes
getting in the way."
  (cond ((not desktop-recover-suppress-save)
         (setq desktop-dirname (file-name-as-directory (expand-file-name dirname)))
         (desktop-remove)
         (desktop-save dirname release)
         )
        (t
         (message "Desktop save skipped, because desktop-recover-suppress-save is set"))
         ))

;;--------
;; window management utilities

(defun desktop-recover-buffer-safe-to-overwrite-p (buffer-name)
  "Verify that a buffer is safe to be over-written.
Currently this is just a check to make sure the given name
follows the convention for dynamic display buffers: it must
begin with a leading asterix."
  (string= (substring buffer-name 0 1) "*"))

(defun desktop-recover-list-in-other-window (list buffer-name)
  "Displays LIST of strings in BUFFER-NAME in a second window.
Closes all other windows except for the current window and the newly created one."
  (unless
      (desktop-recover-buffer-safe-to-overwrite-p buffer-name)
    (error (format "%s does not look safe to over-write." buffer-name)))
  (delete-other-windows)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer buffer-name)
  (mark-whole-buffer)
  (delete-region (mark) (point))
  (insert (mapconcat 'identity list "\n"))
  (deactivate-mark))

;;======================
;; read desktop files

;; desktop.el just loads the .emacs-desktop files (which are elisp code)
;; I want to deal with each file conditionally, so I need to parse it myself
(defun desktop-recover-interactive (&optional dirname)
  "Read the .emacs-desktop file, bring up menu to approve buffer restoration."
  (interactive) ;; maybe: interactive D?
  (let* ( (desktop-file (desktop-recover-file-path dirname))
          ;; an .emacs-desktop file is in sections labeled like so:
          (global-section-marker ";; Global section")
          (buffer-section-marker ";; Buffer section")
          ;; prepend ^ to make them regexps
          (global-section-pattern
            (concat "^" global-section-marker))
          (buffer-section-pattern
            (concat "^" buffer-section-marker))
          (global-section "")
          (buffer-section "")
          (desktop-list)  ;; list of lists, one row for each desktop buffer
         )
    (cond (desktop-file
           (find-file desktop-file)
           ;; parse into global and buffer sections
           ;; TODO need to check the file format version, no?  Warn if it's wrong.
           (goto-char (point-min))
           (re-search-forward global-section-pattern)
           (forward-line 1)
           (let* ((beg (point) )
                  (end))
             (re-search-forward buffer-section-pattern)
             (previous-line 1)
             (move-end-of-line 1)
             (setq end (point))
             (setq global-section (buffer-substring beg end)))
           (forward-line 2)
           (let* ((beg (point) )
                  (end (point-max)))
             (setq buffer-section (buffer-substring beg end)))
           (eval (read global-section))
           (setq desktop-list
                 (desktop-parse-buffer-section buffer-section))
           ;; display the desktop-list in an interactive selection buffer
           (desktop-recover-show-menu desktop-list)
           ))
    ))

(defun desktop-parse-buffer-section (buffer-section)
  "Associate file system names with desktop-create-buffer code.
Parses the 'buffer section' of a .emacs.desktop file (passed in
as the string BUFFER-SECTION) subdividing it into
desktop-create-buffer function calls, and picking out names from
them to use for user confirmation.  Returns the desktop-list, a
list of lists, with one row per buffer, where each row is a
list (in this order) of: name, path, mode, and the
desktop-create-buffer call.  See \\[desktop-recover-desktop-list-doc]."
;;  (interactive) ;; DEBUG only
  (let* ((dcb-string "(desktop-create-buffer")
         (dcb-pattern (format "^[ \t]*?%s[ \t]" dcb-string))
         (dcb-list)
         (dcb-lines)
         (file-format)
         (mode)
         (file-name)  ;; full name, with path
         (name)       ;; file/dir name without path
         (misc)       ;; a list of stuff... multiple paths for tree dired?
         (first-misc) ;; the primary dir in dired-mode (with trailing slash)
         (path)
         (record)
         (desktop-list)
         )
    ;; here we split on the initial funcall string, then prepend it again
    ;; to have the list of complete function calls
    (setq dcb-list
          (mapcar (lambda (item)
                    (concat dcb-string " " item))
                  (split-string buffer-section dcb-pattern t)))
    (dolist (dcb-code dcb-list)
      (message "dcb code: %s\n" dcb-code)
      ;; parse dcb-code as a list
      (setq dcb-lines (split-string dcb-code "\n" t))
      ;;
      (setq file-format (car (cdr (split-string (nth 0 dcb-lines) " " t))))
      (setq file-name (desktop-recover-clean-string (nth 1 dcb-lines)))
      (setq name (desktop-recover-clean-string (nth 2 dcb-lines)))
      (setq mode (desktop-recover-clean-string (nth 3 dcb-lines)))
      (setq misc (nth 8 dcb-lines))  ;; will need extra clean?
      ;;
      (cond ((string= mode "dired-mode")
             (message "case dired")
             (setq first-misc (desktop-recover-snag-first-item misc))
             (setq path first-misc))
            (t
             (message "default (non-dired)")
             (setq path file-name)
             ))
      (setq record
            (append
             (mapcar 'eval
                     '(name path mode dcb-code))
             record))
      (setq desktop-list (cons record desktop-list))
      )
    desktop-list))

;; TODO What advantages does this have over
;;   desktop-recover-location
(defun desktop-recover-file-path (&optional dirname)
  "Returns the full name and path of the desktop file.
Uses the standard name \".emacs.desktop\" (determined from
`desktop-base-file-name'), located either in the given DIRNAME or
in the default `desktop-recover-location'.  It does not check for
the existance of the file.  Sets `desktop-dirname' as a side-effect."
    (setq desktop-dirname
          (file-name-as-directory
           (expand-file-name
            (or
             ;; If DIRNAME is specified, use it.
             (and (< 0 (length dirname)) dirname)
             ;; Otherwise fall back on the default
             desktop-recover-location))))
    ;; now get the full file name.
    (concat
     (desktop-recover-fixdir desktop-dirname)
     desktop-base-file-name)
    )

(defun desktop-recover-clean-string (string)
  "Strip leading/trailing whitespace, and also, leading single-quotes."
  (let ((strip-lead-space-pattern "^[ \t]*\\([^ \t]*.*\\)")
        (strip-trail-space-pattern "\\(.*?\\)[ \t]*$")
        (strip-lead-apostrophe-pattern "^'*\\(.*\\)")
        (temp1)
        (temp2)
        (clean)
        )
    (if
        (string-match strip-lead-space-pattern string)
        (setq temp1 (match-string 1 string))
      (setq temp1 string))
    (if
        (string-match strip-trail-space-pattern temp1)
        (setq temp2 (match-string 1 temp1))
      (setq temp2 temp1))
    (string-match strip-lead-apostrophe-pattern temp2)
    (setq clean (match-string 1 temp2))
    clean))

(defun desktop-recover-snag-first-item (list-string)
  "Get's the first item out of the list stored in LIST-STRING.
Intended to deal with the 'desktop-buffer-misc' field of a desktop-create-buffer call.
Which may look something like:
  '(\"/home/doom/End/Pit/\")
Note: This is not just a wrapper around \"car\", it does the
conversion from string to list first."
  (let* ((list (eval (read list-string)))
         (first-item (car list))
         )
    first-item))


;;========
;; interactive buffer selection for recovery

;; Display a list of marker, name, path, mode,
;; where the marker is set ("*") if buffer is to be loaded,
;; The return key is the "do-it" that accepts the displayed settings,
;; and the "m" and "u" keys control whether the current line is set

(defvar desktop-recover-marker "*"
  "Symbol used to show a buffer will be reloaded \(typically \"*\"\).")

(defvar desktop-recover-autosave-marker "#"
  "Symbol used to show that a more recent auto-save file exists \(typically \"#\"\).")

(defvar desktop-recover-unmarker " "
  "Character used to erase either of the above markers (typically a space).")

(define-derived-mode desktop-recover-mode
  text-mode "desktop-recover"
  "Major mode to display candidates for buffers to be restored when re-starting emacs.
\\{desktop-recover-mode-map}"
  (use-local-map desktop-recover-mode-map)
  )

(define-key desktop-recover-mode-map "\C-m" 'desktop-recover-do-it)
(define-key desktop-recover-mode-map "m"    'desktop-recover-mark-move-down)
(define-key desktop-recover-mode-map "u"    'desktop-recover-unmark-move-down)
(define-key desktop-recover-mode-map "n"    'next-line)
(define-key desktop-recover-mode-map "p"    'previous-line)
(define-key desktop-recover-mode-map "*"    'desktop-recover-mark-move-down)

(defun desktop-recover-do-it ()
  "Accept the current settings of the restore menu buffer.
Runs the appropriate \"desktop-create-buffer\" calls stored
in the desktop-list data structure.  Follows up with a
with auto-save file recovery, if that's indicated."
  (interactive)
  (let* (
         (recover-list-buffer (current-buffer))
         (desktop-recover-suppress-save t) ;; Don't save desktop during load
         (marker-pattern
          (concat "^[ \t]"
                  desktop-recover-marker
                  "\\*")) ;; line begins with asterix
         (auto-save-pattern desktop-recover-autosave-marker)
         (line-count (count-lines (point-min) (point-max)))
         ;; saving the file the cursor is pointing at
         (current-name (get-char-property (point) 'name))
         (current-path (get-char-property (point) 'path))
         ;;
         )
    (goto-char (point-min))
    (while ;; loop over all lines in buffer
        (progn
          (save-excursion
            (move-beginning-of-line 1)
            ;; if line is marked with an asterix...
            (cond ((thing-at-point-looking-at marker-pattern)
                   (let* (
                          ;; unpacking info stashed in 1st char properties
                          (dcb-code (get-char-property (point) 'dcb))
                          (auto-save (get-char-property (point) 'auto-save))
                          ;; (mode (get-char-property (point) 'mode))
                          (name (get-char-property (point) 'name))
                          (path (get-char-property (point) 'path))
                          ;;
                          ;; need to mimic the desktop.el context of dcb calls
                          ;; (even though we don't care about these features).
                          (desktop-first-buffer nil)
                          (desktop-buffer-ok-count 0)
                          (desktop-buffer-fail-count 0)
                          (owner (desktop-owner))
                          )
                     ;; do it to it
                     (eval (read (eval dcb-code))) ; 1st eval is object->string

                     ;; covering a corner case: file was never saved, but
                     ;; there is an auto-save file for it.
                     ;;
                     ;; buffer does not seem to have opened successfully
                     (cond ((not (string= (buffer-name) name))
                            (cond ((and
                                    (desktop-recover-newer-auto-save path)
                                    (string-match auto-save-pattern auto-save))
                                   (file-find path)
                                   (recover-this-file)
                                   ))
                            ))
                     ;; looks like a regular file (not dired, etc),
                     ;; recover auto-save, if that's indicated
                     (let ((bfn (buffer-file-name)))
                       (cond ((and
                               bfn
                               (string-match auto-save-pattern auto-save))
                              (recover-this-file))))
                     )))
            )
          ;; (set-buffer recover-list-buffer) ;; do you *trust* save-excursion?
          (forward-line 1)
          (<= (line-number-at-pos) line-count)))
    ;; after doing a recovery, must clean-up so that this can be used next time
    (desktop-recover-reset-clean-exit-flag)
    ;; TODO bring current-name/current-path to the fore, and do a (list-buffers)
    ))

(defun desktop-recover-mark ()
  "Set the marker for the current line: add leading asterix."
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-marker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-unmark ()
  "Unset the marker for the current line: remove leading asterix."
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-unmarker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-mark-move-down ()
  "Set marker on the current line, move down one."
  (interactive)
  (desktop-recover-mark)
  (forward-line 1))

(defun desktop-recover-unmark-move-down ()
  "Unset marker of the current line, move down one."
  (interactive)
  (desktop-recover-unmark)
  (forward-line 1))

;; TODO
;; Add commands to allow the user to manually reject an auto-save file?
;; (that would be a very unusual case, and the user will *never*
;; remember that the feature exists).

;; This is intended to be run at emacs init time (run from
;; desktop-recover-interactive) so there's no need for a keybinding
(defun desktop-recover-show-menu (desktop-list)
  "Displays info about buffers that are candidates to be restored.
These are buffers that existed when the last desktop save was done."
;; TODO Is there a reason to allow concurrent usage? Will need
;; multiple unique buffer names rather than just desktop-recover-buffer-name
  (interactive)
  (let* ((menu-contents))
    (setq menu-contents (desktop-recover-build-menu-contents desktop-list))
    (switch-to-buffer desktop-recover-buffer-name)
    (setq buffer-read-only nil)
    (delete-region (point-min) (point-max))
    (insert menu-contents)
    (desktop-recover-mode)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-build-menu-contents (desktop-list)
  "Builds the menu text from the DESKTOP-LIST data."
  (let* ((name) (path) (mode) (dcb-code)
        (marker desktop-recover-marker)     ;; "*"
        (unmarker desktop-recover-unmarker) ;; " "
        (auto-save-mark desktop-recover-autosave-marker) ;; "#"
        (line "")
        (menu-contents "")
        ;; (line-fmt " %1s %-33s%-42s %1s")
        (line-fmt (desktop-recover-menu-format desktop-list))
        (marker-field)
        (auto-save-field)
        )
    (dolist (record desktop-list)
      ;; unpack the record
      (setq name     (nth 0 record))
      (setq path     (nth 1 record))
      (setq mode     (nth 2 record))
      (setq dcb-code (nth 3 record))
      (setq marker-field
            (cond ((desktop-recover-by-default-p record)
                   desktop-recover-marker)
                  (t
                   desktop-recover-unmarker)
                  ))
      (setq auto-save-field
            (cond ((desktop-recover-newer-auto-save path)
                   auto-save-mark)
                  (t
                   desktop-recover-unmarker)
                  ))
      (setq line (format
                  line-fmt
                  marker-field
                  name
                  path
                  auto-save-field
                  ))
      ;; saving the dcb code block out-of-sight, attached to first character
      (put-text-property 0 1 'dcb dcb-code line)
      ;;
      ;; for convenience, preserving the visible fields also
      (put-text-property 0 1 'name name line)
      (put-text-property 0 1 'path path line)
      (put-text-property 0 1 'mode mode line)
      (put-text-property 0 1 'marker marker-field line)
      (put-text-property 0 1 'auto-save auto-save-field line)
      (setq menu-contents
            (concat menu-contents line "\n")
      ))
    menu-contents))


;; four fields: marker  name  path  auto-save-marker
(defun desktop-recover-menu-format (desktop-list)
  "Choose the menu format, balancing between lengths of name and path."
  (let* ((name) (path) (width-name) (width-path)
         (total-width 80) ;; TODO break-out as var
         (max-name 0)
         ;; (max-path 0)    ;; Not making any use of max-path at present
         (line-fmt "")
         )
    (dolist (record desktop-list)
      (setq name     (nth 0 record))
      (setq path     (nth 1 record))
      (if (> (length name) max-name)
          (setq max-name (length name)))
      ;; (if (> (length path) max-path)
      ;; (setq max-path (length path)))
        )
    ;; Goal: (line-fmt " %1s %-33s%-42s %1s")
    (setq width-name (+ max-name 2))
    (setq width-path (- total-width 5 width-name))
    (setq line-fmt
          (concat
           " %1s %-"
           (number-to-string width-name)
           "s%-"
           (number-to-string width-path)
           "s %1s"))
    line-fmt))

(defun desktop-recover-reset-clean-exit-flag ()
  "Erase the file used to flag that emacs exited cleanly."
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         )
         (if (file-exists-p clean-exit-flag-file)
             (delete-file clean-exit-flag-file)
             )
    ))

(defun desktop-recover-clean-exit-p ()
  "Does it look like emacs exited cleanly?"
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         (retval (file-exists-p clean-exit-flag-file))
         )
    retval))

;; TODO this has access to the mode -- why not use it?
;; could distinguish between dired & shell buffers at this stage?
;; might be good to do dynamic buffer filtering later than I am...
(defun desktop-recover-by-default-p (record)
  "Examine RECORD to determine if this buffer should be reloaded by default.
A file should not be re-loaded if was an automatically saved temporary
buffer and emacs exited cleanly.  RECORD should be a list of
name, path, mode and dcb-code."
  (let* ((name) (path) (mode) (dcb-code)
         (tmp-dir (desktop-recover-fixdir desktop-recover-tmp-dir))
         (recover-p t) ;; return value
         )
    ;; unpack the record
    (setq name     (nth 0 record))
    (setq path     (nth 1 record))
    (setq mode     (nth 2 record))
    (setq dcb-code (nth 3 record))
;;    (message "the temp directory: %s" tmp-dir) ;; DEBUG
    (cond ((and
            (string= (desktop-recover-fixdir path) tmp-dir)
            (desktop-recover-clean-exit-p))
           (setq recover-p nil))
          )
    recover-p))

(defun desktop-recover-newer-auto-save (path)
  "Given PATH (full path and file name) check for newer auto-save file."
  (let* (
         (name (file-name-nondirectory path)) ;; could just pass this in also
         (loc  (file-name-directory path))
         (a-s-name (format "#%s#" name))
         (auto-save (concat loc a-s-name))
         )
    ;; if autosave does not exist, this is nil
    (file-newer-than-file-p auto-save path)
    ))

;;=======
;; boneyard

(defun desktop-read-initialization-old (&optional dirname)
  "Does precisely the same folderol as the desktop-read function,
up to the point where it loads the desktop file: instead it returns the
full name of the desktop file located in DIRNAME."
;; TODO Consider the possibility that "desktop.el" is completely out-to-lunch
;; half of the time, and that slavishly imitating it is bad news, as this
;; routine clearly is.
  (unless noninteractive ;; whole function is a no-op if used interactively...
    (setq desktop-dirname
          (file-name-as-directory
           (expand-file-name
            (or
             ;; If DIRNAME is specified, use it.
             (and (< 0 (length dirname)) dirname)
             ;; Otherwise search desktop file in desktop-path.
             (let ((dirs desktop-path))
               (while (and dirs
                           (not (file-exists-p
                                 (desktop-full-file-name (car dirs)))))
                 (setq dirs (cdr dirs)))
               (and dirs (car dirs)))
             ;; If not found and `desktop-path' is non-nil, use its first element.
             (and desktop-path (car desktop-path))
             ;; Default: Home directory.
             "~"))))
    (if (file-exists-p (desktop-full-file-name))
	;; Desktop file found, but is it already in use?
	(let ((desktop-first-buffer nil)
	      (desktop-buffer-ok-count 0)
	      (desktop-buffer-fail-count 0)
	      (owner (desktop-owner))
	      ;; Avoid desktop saving during evaluation of desktop buffer.
	      (desktop-save nil))
	  (if (and owner
		   (memq desktop-load-locked-desktop '(nil ask))
		   (or (null desktop-load-locked-desktop)
		       (not (y-or-n-p (format "Warning: desktop file appears to be in use by PID %s.\n\
Using it may cause conflicts.  Use it anyway? " owner)))))
	      (let ((default-directory desktop-dirname))
		(setq desktop-dirname nil)
		(run-hooks 'desktop-not-loaded-hook)
		(unless desktop-dirname
		  (message "Desktop file in use; not loaded.")))
	    (desktop-lazy-abort)

            (desktop-full-file-name) ;; TODO question: why not pass in a dirname?
                                     ;; relies on default-directory to pass the value?

            ;; returns the file name (make this clearer?)

	    ))
      ;; No desktop file found.
      (desktop-clear) ;; -- TODO so why are we fucking clearing the desktop?
      (let ((default-directory desktop-dirname))
        (run-hooks 'desktop-no-desktop-file-hook))
      (message "No desktop file.")
      nil)))

;; TODO not in use
;; I don't see any need for these features at all, actually...
;; the buffer order juggling is not very useful for my purposes
;; And the detailed report of success or failure seems totally useless...
;; if the file you wanted didn't get opened, you'll just go open it.
(defun desktop-read-tail (&optional dirname)
  "The code that the desktop-read function executes after loading the desktop file.
This folderol was cut and paste from there on the theory that whatever it is
that this is doing it may be a good idea for me to do also."
  (interactive)
  ;;; TODO add anything else here?
  ;;;
  ;; Remember when desktop buffer was modified.
  (setq desktop-file-modtime (nth 5 (file-attributes (desktop-full-file-name))))
  ;; If it wasn't already, mark it as in-use, to bother other
  ;; desktop instances.
  (unless owner
    (condition-case nil
        (desktop-claim-lock)
      (file-error (message "Couldn't record use of desktop file")
                  (sit-for 1))))

  ;; `desktop-create-buffer' puts buffers at end of the buffer list.
  ;; We want buffers existing prior to evaluating the desktop (and
  ;; not reused) to be placed at the end of the buffer list, so we
  ;; move them here.
  (mapc 'bury-buffer
        (nreverse (cdr (memq desktop-first-buffer (nreverse (buffer-list))))))
  (switch-to-buffer (car (buffer-list)))
  (run-hooks 'desktop-delay-hook)
  (setq desktop-delay-hook nil)
  (run-hooks 'desktop-after-read-hook)
  (message "Desktop: %d buffer%s restored%s%s."
           desktop-buffer-ok-count
           (if (= 1 desktop-buffer-ok-count) "" "s")
           (if (< 0 desktop-buffer-fail-count)
               (format ", %d failed to restore" desktop-buffer-fail-count)
             "")
           (if desktop-buffer-args-list
               (format ", %d to restore lazily"
                       (length desktop-buffer-args-list))
             ""))
  )

(defun desktop-recover-list-dangling-buffers-original ()
  "List buffers without files or directories, skipping internal and display (*) buffers.
Returns a list of buffer objects."
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (output-list)
         )
    (save-excursion
      (dolist (buffy (buffer-list))
        (set-buffer buffy) ; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy) )
               (buffy-name (buffer-name  buffy) )
               )
          (cond (
                 (and
                  ;; looking for buffers without file names
                  (not file-nameo)
                  ;; Skip directories
                  (not (string= major-mode "dired-mode"))
                  ;; Skip internal buffers.
                  (not (string= (substring buffy-name 0 1) " "))
                  ;; Skip dynamic display buffers
                  (not (string= (substring buffy-name 0 1) "*"))
                  ;; Skip shell and debugger buffers (even without leading "*")
                  (not (or
                        (string= major-mode "shell-mode")
                        (string= major-mode "eshell-mode")
                        (string= major-mode "gud-mode")))
                  )
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer preserve-buffer)
      (deactivate-mark)
  output-list)))

;; ---------
;; boneyard of desktop-save routines
;; these are functional, but not in use (they were largely for debug purposes)

(defun desktop-recover-display-dangling-buffers ()
  "List buffers without files or directories, skipping internal and display (*) buffers.
Returns a list of buffer objects."
  (interactive)
  (let* ((dangling-buffers (desktop-recover-list-dangling-buffers))
         (buffname-list  (mapcar 'buffer-name dangling-buffers))
         )
    (desktop-recover-list-in-other-window buffname-list "*mah buffers*")
    ))

(defun desktop-recover-list-ordinary-buffer-names ()
  "List names of ordinary buffers, skipping dired, internal and display (*) buffers.
Returns a list of buffer names.  Note that 'ordinary' buffers include
'dangling' buffers without associated files."
  (interactive)
  (let* ( (ordinary-buffers (desktop-recover-list-ordinary-buffers))
          (buffname-list  (mapcar 'buffer-name ordinary-buffers) )
                 )
    buffname-list))

(defun desktop-recover-print-ordinary-buffer-names ()
  "Print ordinary buffer names (non-directory, non-asterix, non-internal)."
  (interactive)
  (let* ( (buff_list   (desktop-recover-list-ordinary-buffer-names) )
          (buff_string (mapconcat 'identity buff_list "\n")) )
    (print buff_string)
    ))

(defun desktop-recover-insert-ordinary-buffer-names ()
  "Insert ordinary buffer names (non-directory, non-asterix, non-internal).
Inserts names into the current buffer, at point, one on each line."
  (interactive)
  (let* ( (buff_list   (desktop-recover-list-ordinary-buffer-names) )
;          (buff_string (mapconcat 'identity buff_list "\n"))
          )
    (dolist (item buff_list)
            (insert item)
            ;; (insert "\n")
            (newline 1)
    )))



;;; desktop-recover.el ends here

