;;; desktop-recover.el ---

;; Copyright 2009 Joseph Brenner
;;
;; Author: doom@kzsu.stanford.edu
;; Version: $Id: desktop-recover.el,v 0.0 2009/07/08 02:59:21 doom Exp $
;; Keywords:
;; X-URL: not distributed yet

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software
;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

;;; Commentary:

;;  Works with the .emacs-desktop files (as generated by desktop.el),
;;  but unlike with desktop-read, provides an interactive menu that
;;  let's the user choose which buffers will be restored.

;; Put this file into your load-path and the following into your ~/.emacs:
;;   (require 'desktop-recover)

;;; Code:

(provide 'desktop-recover)
(eval-when-compile
  (require 'cl))

(require 'desktop)
(require 'thingatpt)



;;======
;; poor man's pod/lazy man's info:
;;   dummy variables with documentation attached

(defvar desktop-recover-desktop-list-doc ""
  "Many functions in this package work with a data-structure
typically called the \"desktop-list\". This describes the buffers
recorded in the .emacs-desktop file, which are candidates to be
re-loaded when desktop-recover-interactive is run.  The
desktop-list is a list of lists, with one row per buffer, where
each row is a list of (in this order): name, path, mode, and the
desktop-create-buffer call.  The \"name\" is the name sans path,
the \"path\" is the full-name, including path, the mode is the
name of the associated emacs mode (e.g. \"text-mode\"), and the
\"desktop-create-buffer call\" is the code (in string form) that
will need to be run to restore the buffer.")

(defvar desktop-recover-dangling-buffers-doc ""
  "We use \"dangling buffers\" to mean buffers without associated files.
Typically we will exclude the special display buffers (which
usually begin with an asterix), dired buffers, and so on.  We're
concerned here with buffers used for temporary notes that might've
been prematurely lost by an emacs crash \(due to a broken connect\).

Along with the automated desktop save feature, we will make save
these dangling buffers to temporary files, making them a little
less ephemeral, though not as permanent as ordinary files.
A clean exit from emacs should erase them.")

;;;;##########################################################################
;;;;  User Options, Variables
;;;;##########################################################################

;; defining this first to use it in following defvars, etc.
(defun desktop-recover-fixdir (dir &optional root)
  "Fixes the DIR.
Conditions directory paths for portability and robustness.
Some examples:
 '~/tmp'             => '/home/doom/tmp/'
 '~/tmp/../bin/test' => '/home/bin/test/'
Note: converts relative paths to absolute, using the current
default-directory setting, unless specified otherwise with the
ROOT option. As a side-effect: converts the empty string into
the default-directory or the ROOT setting."
  (let ((return
         (substitute-in-file-name
          (convert-standard-filename
           (file-name-as-directory
            (expand-file-name dir root))))))
    return))

(defcustom desktop-recover-tmp-dir
  (substitute-in-file-name
   "$HOME/.emacs.d/desktop-recover-tmp")
  "Location where dangling buffers that have no associated files are saved.")

(defcustom desktop-recover-location "$HOME/.emacs.d"
  "The default location from which we save and restore desktop files.
Note: desktop.el has a desktop-dirname location, but that can not be
used reliably as a user setting, because the code changes it under some
circumstances.")
(put 'desktop-recover-location 'risky-local-variable t)
(setq desktop-recover-location
      (desktop-recover-fixdir desktop-recover-location))

;; TODO going away soon
(defvar desktop-recover-clean-exit-flag "desktop_recover_clean_exit.flag"
  "The existance of a file of this name signals that we did a clean exit.")

(defvar desktop-recover-buffer-name "*Desktop Buffer Restore Menu*"
  "Buffer name for the desktop restore menu.")

;;======================
;; saving desktop files

;; TODO Add a way to turn this off?  Any safety features to add?
;; e.g. don't do "recovery" if saves are enabled... (or deactivate
;; saves during a recovery?  better.)
(defun desktop-recover-do-saves-automatically ()
  "Makes the desktop saved automatically using the auto-save-hook."
  (add-hook 'auto-save-hook
            (lambda ()
              (desktop-recover-save-with-danglers))))

;; TODO
;; Need a way to skip things like my ubiquitous "shell-misc" buffers.
;; desktop.el has a skip list, right?
;; Simplest thing for me to do: rename it "*shell-misc*"... but that
;; breaks my old keystroke macros.
;;
;; Would it make sense to be able to skip all shell buffers?
;; Ideally: provide a list of major-modes that will be skipped,
;; so file/buffer names don't matter so much.
(defun desktop-recover-save-with-danglers ()
  "Desktop autosave routine that preserves buffers that have no associated files.
Works by saving them to a standard tmp directory, then using desktop.el to save
them along with the other open files.  After re-starting emacs, you should then
have buffers corresponding to the old dangling buffers (though now they'll be
associated with files in the special tmp location).
See: `desktop-recover-dangling-buffers-doc'"
  (interactive)
  (let* ( (DEBUG nil)
          (preserve-buffer (current-buffer))
          (temp-loc desktop-recover-tmp-dir)
          (dangling-buffers (desktop-recover-list-dangling-buffers))
          )
    (unless (file-exists-p temp-loc)
      (make-directory temp-loc t))

    ;; save each to temp location using a file name identical to the buffer name,
    (dolist (buffy dangling-buffers)
            (set-buffer buffy)
            (let* (
                    (  buffy-name (buffer-name  buffy) )
                    (  file-nameo (concat temp-loc "/" buffy-name) )
                    )
              (write-file file-nameo) ;; this *is* saving the buffer in the tmp location,
                                      ;; but something is destroying the dangling buffers
              ))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
    ;; (desktop-save-in-desktop-dir)
    (desktop-recover-force-save-in-desktop-dir)
    (desktop-recover-clear-clean-save-flag)  ;; TODO about to go away
  ))

(defun desktop-recover-display-dangling-buffers ()
  "List buffers without files or directories, skipping internal and display (*) buffers.
Returns a list of buffer objects."
  (interactive)
  (let* ( (dangling-buffers (desktop-recover-list-dangling-buffers))
          (buffname-list  (mapcar 'buffer-name dangling-buffers) )
                 )
      (desktop-recover-list-in-other-window buffname-list "*mah buffers*")
    ))

;; TODO should this be refactored to use desktop-recover-list-ordinary-buffers ?
;; that would change behavior: skips dired buffers
(defun desktop-recover-list-dangling-buffers ()
  "List buffers without files or directories, skipping internal and display (*) buffers.
Returns a list of buffer objects."
  (interactive)
  (let* ((DEBUG nil)
         (preserve-buffer (current-buffer))
         (output-list)
         )
    (and DEBUG (message "running desktop-recover-list-dangling-buffers"))
    (save-excursion
      (dolist (buffy (buffer-list))
        (set-buffer buffy) ; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy) )
               (buffy-name (buffer-name  buffy) )
               )
          (cond (
                 (and
                  ;; looking for buffers without file names
                  (not file-nameo)
                  ;; Skip directories
                  (not (string= major-mode "dired-mode")) ;; TODO any better way?
                  ;; Skip internal buffers.
                  (not (string= (substring buffy-name 0 1) " "))
                  ;; Skip dynamic display buffers
                  (not (string= (substring buffy-name 0 1) "*"))
                  )
                 (and DEBUG (message "buffer without associated file: %s" buffy-name))
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer preserve-buffer)
      (deactivate-mark)
      (and DEBUG (message "finished desktop-recover-list-dangling-buffers"))
  output-list)))

(defun desktop-recover-list-ordinary-buffers ()
  "List buffers, skipping dired buffers, internal and display (*) buffers.
Returns a list of buffer objects.  Note that 'ordinary' buffers include
'dangling' buffers without associated files."
  (interactive)
  (let* ( (DEBUG nil)
          (preserve-buffer (current-buffer))
          (output-list)
        )
    (and DEBUG (message "running desktop-recover-list-ordinary-buffers"))
    (save-excursion
      (dolist (buffy (buffer-list))
        (set-buffer buffy) ; switch to buffer so we can check 'major-mode'
        (let* ( (  file-nameo (buffer-file-name buffy) )
                (  buffy-name (buffer-name  buffy) )
                )
          (cond (
                 (and
                  ;; Skip directories
                  (not (string= major-mode "dired-mode")) ;; TODO any better way?
                  ;; Skip internal buffers (begin with space)
                  (not (string= (substring buffy-name 0 1) " "))
                  ;; Skip dynamic display buffers (begin with asterix)
                  (not (string= (substring buffy-name 0 1) "*"))
                  )
                 (and DEBUG (message "buffer: %s" buffy-name))
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer preserve-buffer)
      (deactivate-mark)
      (and DEBUG (message "finished desktop-recover-list-ordinary-buffers"))
  output-list)))


(defun desktop-recover-list-ordinary-buffer-names ()
  "List names of ordinary buffers, skipping dired, internal and display (*) buffers.
Returns a list of buffer names.  Note that 'ordinary' buffers include
'dangling' buffers without associated files."
  (interactive)
  (let* ( (ordinary-buffers (desktop-recover-list-ordinary-buffers))
          (buffname-list  (mapcar 'buffer-name ordinary-buffers) )
                 )
    buffname-list))

;; TODO -- there's a need for window handling utilities and usage standards
;; TODO -- Make buffer name optional (generated default)
;; TODO -- only works with a list of strings.
;;         is there pp code that would work with, say, a list of objects like buffers?
(defun desktop-recover-buffer-safe-to-overwrite-p (buffer-name)
  "Verify that a buffer is safe to be over-written.
Currently this is just a check to make sure the given name
follows the convention for dynamic display buffers: it must
begin with a leading asterix."
  (string= (substring buffer-name 0 1) "*"))

(defun desktop-recover-list-in-other-window (list buffer-name)
  "Dipplays LIST of strings in BUFFER-NAME in a second window.
Closes all other windows except for the current window and the newly created one."
  (unless
      (desktop-recover-buffer-safe-to-overwrite-p buffer-name)
    (error (format "%s does not look safe to over-write." buffer-name)))
  (delete-other-windows)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer buffer-name)
  (mark-whole-buffer)
  (delete-region (mark) (point))
  (insert (mapconcat 'identity list "\n"))   ;;; TODO how to insert a list?
  (deactivate-mark))

(defun desktop-recover-print-ordinary-buffer-names ()
  "Print ordinary buffer names (non-directory, non-asterix, non-internal)."
  (interactive)
  (let* ( (buff_list   (desktop-recover-list-ordinary-buffer-names) )
          (buff_string (mapconcat 'identity buff_list "\n")) )
    (print buff_string)
    ))

(defun desktop-recover-insert-ordinary-buffer-names ()
  "Insert ordinary buffer names (non-directory, non-asterix, non-internal).
Inserts names into the current buffer, at point, one on each line."
  (interactive)
  (let* ( (buff_list   (desktop-recover-list-ordinary-buffer-names) )
;          (buff_string (mapconcat 'identity buff_list "\n"))
          )
    (dolist (item buff_list)
            (insert item)
            (insert "\n")
    )))

;; TODO request a hook to do this.  Doesn't seem to exist.
;; TODO
;; Of the various ways of doing this, let's try just touching a file here,
;; which the autosave code will delete. (would the reverse be better?)
;; TODO better than touch: use emacs to save a buffer that has an
;; identifying message in it (current pid?) (Oh: list of stuff to
;; be saved... then you could check timestamps later to see if they
;; all were saved...)
(defun desktop-recover-save-buffers-kill-terminal ()
  "Wrapper around save-buffers-kill-terminal to flag clean exits.
Actually, it flags the fact that we *tried* to exit cleanly, since
there's easy no way to check if all saves were completed before
emacs died."
  (let* (
         ;; TODO going away soon.
         (clean-exit-flag-file
           (concat
            (desktop-recover-fixdir
             desktop-recover-tmp-dir)
            desktop-recover-clean-exit-flag))
         ;; set these to override defaults
         (output-buffer nil)
         (error-buffer  nil)
         (cmd (format "touch %s" clean-exit-flag-file))
         )
    (desktop-recover-save-with-danglers) ;; TODO double-check. right save?
    ;; we do this *after* the above, because that also clears the flag
    (shell-command cmd output-buffer error-buffer)

    ;; TODO we're just doing a save here that *doesn't* save the danglers.
    ;; thus, all of the above then all goes away.
    ;; (desktop-recover-force-save-in-desktop-dir)
    (save-buffers-kill-terminal)
    ))

;; TODO about to go away
(defun desktop-recover-clear-clean-save-flag ()
  "Remove the clean save flag (until the next clean save really happens)."
  (let* (( clean-exit-flag-file
           (concat
            (desktop-recover-fixdir
             desktop-recover-tmp-dir)
            desktop-recover-clean-exit-flag))
         )
    (delete-file clean-exit-flag-file)
    ))


(defun desktop-recover-force-save (dirname &optional release)
   "Force save of desktop by wiping out any existing file first.
This ensures you will not have any question about modtimes
getting in the way."
   (message "desktop-force-save called")
   (setq desktop-dirname (file-name-as-directory (expand-file-name dirname)))
   (desktop-remove)
   (desktop-save dirname release)
   )

(defun desktop-recover-force-save-in-desktop-dir ()
  "Save the desktop in directory `desktop-dirname'."
  (interactive)
  (if desktop-dirname
      (desktop-recover-force-save desktop-dirname)
    (call-interactively 'desktop-save))
  (message "Desktop saved in %s" (abbreviate-file-name desktop-dirname)))

;;======================
;; read desktop files

;; desktop.el just loads the .emacs-desktop files (which are elisp code)
;; I want to deal with each file conditionally, so I need to parse it myself
(defun desktop-recover-interactive (&optional dirname)
  "Read the .emacs-desktop file, bring up menu to approve buffer restoration."
  (interactive) ;; maybe: interactive D?
  (let* ( (desktop-file (desktop-recover-file-path dirname))
          ;; an .emacs-desktop file is in sections labeled like so:
          (global-section-marker ";; Global section")
          (buffer-section-marker ";; Buffer section")
          ;; prepend ^ to make them regexps
          (global-section-pattern
            (concat "^" global-section-marker))
          (buffer-section-pattern
            (concat "^" buffer-section-marker))
          (global-section "")
          (buffer-section "")
          (desktop-list)  ;; list of lists, one row for each desktop buffer
         )
    (cond (desktop-file
           (find-file desktop-file)
           ;; parse into global and buffer sections
           ;; TODO need to check the file format version, no?  Warn if it's wrong.
           (goto-char (point-min))
           (re-search-forward global-section-pattern)
           (forward-line 1)
           (let* ((beg (point) )
                  (end))
             (re-search-forward buffer-section-pattern)
             (previous-line 1)
             (move-end-of-line 1)
             (setq end (point))
             (setq global-section (buffer-substring beg end)))
           (forward-line 2)
           (let* ((beg (point) )
                  (end (point-max)))
             (setq buffer-section (buffer-substring beg end)))
           (eval (read global-section))
           (setq desktop-list
                 (desktop-parse-buffer-section buffer-section))
           ;; display the desktop-list in an interactive selection buffer
           (desktop-recover-show-menu desktop-list)
           ))
    ))

(defun desktop-parse-buffer-section (buffer-section)
  "Associate file system names with desktop-create-buffer code.
Parses the 'buffer section' of a .emacs.desktop file (passed in
as the string BUFFER-SECTION) subdividing it into
desktop-create-buffer function calls, and picking out names from
them to use for user confirmation.  Returns the desktop-list, a
list of lists, with one row per buffer, where each row is a
list (in this order) of: name, path, mode, and the
desktop-create-buffer call.  See \\[desktop-recover-desktop-list-doc]."
  (interactive) ;; DEBUG only
  (let* ((dcb-string "(desktop-create-buffer")
         (dcb-pattern (format "^[ \t]*?%s[ \t]" dcb-string))
         (dcb-list)
         (dcb-lines)
         (file-format)
         (mode)
         (file-name)  ;; full name, with path
         (name)       ;; file/dir name without path
         (misc)       ;; a list of stuff... multiple paths for tree dired?
         (first-misc) ;; the primary dir in dired-mode (with trailing slash)
         (path)
         (record)
         (desktop-list)
         )
    ;; here we split on the initial funcall string, then prepend it again
    ;; to have the list of complete function calls
    (setq dcb-list
          (mapcar (lambda (item)
                    (concat dcb-string " " item))
                  (split-string buffer-section dcb-pattern t)))
    (dolist (dcb-code dcb-list)
      (message "dcb code: %s\n" dcb-code)
      ;; parse dcb-code as a list
      (setq dcb-lines (split-string dcb-code "\n" t))
      ;;
      (setq file-format (car (cdr (split-string (nth 0 dcb-lines) " " t))))
      (setq file-name (desktop-recover-clean-string (nth 1 dcb-lines)))
      (setq name (desktop-recover-clean-string (nth 2 dcb-lines)))
      (setq mode (desktop-recover-clean-string (nth 3 dcb-lines)))
      (setq misc (nth 8 dcb-lines))  ;; will need extra clean?
      ;;
      (cond ((string= mode "dired-mode")
             (message "case dired")
             (setq first-misc (desktop-recover-snag-first-item misc))
             (setq path first-misc))
            (t
             (message "default (non-dired)")
             (setq path file-name)
             ))
      (setq record
            (append
             (mapcar 'eval
                     '(name path mode dcb-code))
             record))
      (setq desktop-list (cons record desktop-list))
      )
    desktop-list))

(defun desktop-recover-file-path (&optional dirname)
  "Returns the full name and path of the desktop file.
Uses the standard name \".emacs.desktop\" (determined from
`desktop-base-file-name'), located either in the given DIRNAME or
in the default `desktop-recover-location'.  It does not check for
the existance of the file."
    (setq desktop-dirname
          (file-name-as-directory
           (expand-file-name
            (or
             ;; If DIRNAME is specified, use it.
             (and (< 0 (length dirname)) dirname)
             ;; Otherwise fall back on the default
             desktop-recover-location))))
    ;; now get the full file name.
    (concat
     (desktop-recover-fixdir desktop-dirname)
     desktop-base-file-name)
    )

(defun desktop-recover-clean-string (string)
  "Strip leading/trailing whitespace, and also, leading single-quotes."
  (let ((strip-lead-space-pattern "^[ \t]*\\([^ \t]*.*\\)")
        (strip-trail-space-pattern "\\(.*?\\)[ \t]*$")
        (strip-lead-apostrophe-pattern "^'*\\(.*\\)")
        (temp1)
        (temp2)
        (clean)
        )
    (if
        (string-match strip-lead-space-pattern string)
        (setq temp1 (match-string 1 string))
      (setq temp1 string))
    (if
        (string-match strip-trail-space-pattern temp1)
        (setq temp2 (match-string 1 temp1))
      (setq temp2 temp1))
    (string-match strip-lead-apostrophe-pattern temp2)
    (setq clean (match-string 1 temp2))
    clean))

(defun desktop-recover-snag-first-item (list-string)
  "Get's the first item out of the list stored in LIST-STRING.
Intended to deal with the 'desktop-buffer-misc' field of a desktop-create-buffer call.
Which may look something like:
  '(\"/home/doom/End/Pit/\")
Note: This is not just a wrapper around \"car\", it does the
conversion from string to list first."
  (let* ((list (eval (read list-string)))
         (first-item (car list))
         )
    first-item))


;;========
;; interactive buffer selection for recovery

;; Display a list of marker, name, path, mode,
;; where the marker is set ("*") if buffer is to be loaded,
;; The return key is the "do-it" that accepts the displayed settings,
;; and the "m" and "u" keys control whether the current line is set

(defvar desktop-recover-unmarker " "
  "Symbol used for an unmarked buffer that will not be reloaded by default.")

(defvar desktop-recover-marker "*"
  "Symbol used for a marked buffer that will be reloaded by default.")

(define-derived-mode desktop-recover-mode
  text-mode "desktop-recover"
  "Major mode to display candidates for buffers to be restored when re-starting emacs.
\\{desktop-recover-mode-map}"
  (use-local-map desktop-recover-mode-map)
  )

(define-key desktop-recover-mode-map "\C-m" 'desktop-recover-do-it)
(define-key desktop-recover-mode-map "m"    'desktop-recover-mark-move-down)
(define-key desktop-recover-mode-map "u"    'desktop-recover-unmark-move-down)
(define-key desktop-recover-mode-map "n"    'next-line)
(define-key desktop-recover-mode-map "p"    'previous-line)
(define-key desktop-recover-mode-map "*"    'desktop-recover-mark-move-down)

;; TODO SOON need a more complicated routine that doesn't just run the dcb
;; but also gets the path, checks for a newer autosave
;;   (if (desktop-recover-newer-auto-save path)
;;       (recover-this-file))
;; Q: is there any reason not to *always* do this recover step?
;; might want to be able to toggle it off, so check the trailing marker as well
(defun desktop-recover-do-it ()
  "Accept the current settings of the restore menu buffer.
Runs the appropriate \"descktop-create-buffer\" calls stored
in the desktop-list data structure."
  (interactive)
  (let* (
         (marker-pattern "^[ \t]*\\*") ;; line begins with asterix
         (line-count (count-lines (point-min) (point-max)))
         (dcb-code)
         (dcb-list)
         )
    (goto-char (point-min))
    (while ;; loop over all lines in buffer
        (progn
          (save-excursion
            (move-beginning-of-line 1)
            ;; if line is marked with an asterix...
            (if (thing-at-point-looking-at marker-pattern)
                (progn
                  (setq dcb-code
                        (get-char-property (point) 'dcb))
                  ;; Save up the dcb-code sexps in a list, to execute later
                  (setq dcb-list (cons (eval dcb-code) dcb-list))
                  )))
          (forward-line 1)
          (< (line-number-at-pos) line-count)
          ))
    (dolist (dcb dcb-list)
      (eval (read dcb)))
    ))

(defun desktop-recover-mark ()
  "Set the marker for the current line: add leading asterix."
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-marker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-unmark ()
  "Unset the marker for the current line: remove leading asterix."
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-unmarker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-mark-move-down ()
  "Set marker on the current line, move down one."
  (interactive)
  (desktop-recover-mark)
  (forward-line 1))

(defun desktop-recover-unmark-move-down ()
  "Unset marker of the current line, move down one."
  (interactive)
  (desktop-recover-unmark)
  (forward-line 1))

;; TODO
;; Do I need to add commands to allow the user to manually
;; reject an auto-save file?

;; This is intended to be run at emacs init time (run from
;; desktop-recover-interactive) so there's no need for a keybinding
(defun desktop-recover-show-menu (desktop-list)
  "Displays info about buffers that are candidates to be restored.
These are buffers that existed when the last desktop save was done."
;; TODO If there's a reason to allow concurrent usage? Will need
;; multiple unique buffer names rather than just desktop-recover-buffer-name
  (interactive)
  (let* ((menu-contents))
    (setq menu-contents (desktop-recover-build-menu-contents desktop-list))

    (switch-to-buffer desktop-recover-buffer-name)
    (setq buffer-read-only nil)
    (mark-whole-buffer)               ;; TODO find more elispy way?
    (delete-region (mark) (point))
    (insert menu-contents)
    (desktop-recover-mode)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-build-menu-contents (desktop-list)
  "Builds the menu text from the DESKTOP-LIST data."
  (let (
         (name) (path) (mode) (dcb-code)
         (marker "*")
         (hash-mark "#")
         (line "")
         (menu-contents "")
         (line-fmt "%3s%-35s%-42s")
         )
         (dolist (record desktop-list)
           ;; unpack the record
           (setq name     (nth 0 record))
           (setq path     (nth 1 record))
           (setq mode     (nth 2 record))
           (setq dcb-code (nth 3 record))
           (cond ((desktop-recover-by-default-p record)
                  (setq line (format
                              line-fmt
                              (concat " " desktop-recover-marker " ")
                              name
                              path
                              )))
                  (t
                   (setq line (format line-fmt
                               (concat " " desktop-recover-unmarker " ")
                               name
                               path
                               ))
                   ))
           (put-text-property 0 1 'dcb dcb-code line)
           ;; TODO make this part of the above line-fmt?
           (if (desktop-recover-newer-auto-save path)
               (set1 line (concat line " " hash-mark)))
           (setq menu-contents
                 (concat menu-contents line "\n"))
           )
         menu-contents))

(defun desktop-recover-clean-exit-p ()
  "Does it look like emacs exited cleanly?"
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         (retval (file-exists-p clean-exit-flag-file))
         )
    retval))

(defun desktop-recover-by-default-p (record)
  "Examine RECORD to determine if this buffer should be reloaded by default.
A file should not be re-loaded if was an automatically saved temporary
buffer and emacs exited cleanly.  RECORD should be a list of
name, path, mode and dcb-code."
  (let* (
         (name) (path) (mode) (dcb-code)
         (clean-exit-p (desktop-recover-clean-exit-p))
         (tmp-dir (desktop-recover-fixdir desktop-recover-tmp-dir))
         (recover-p t) ;; return value
         )
    ;; unpack the record
    (setq name     (nth 0 record))
    (setq path     (nth 1 record))
    (setq mode     (nth 2 record))
    (setq dcb-code (nth 3 record))
    (message "the temp directory: %s" tmp-dir) ;; DEBUG
    (cond ((and
            (string=
             (desktop-recover-fixdir path)
             tmp-dir)
            (clean-exit-p))
           (setq recover-p nil))
          )
    recover-p))

(defun desktop-recover-newer-auto-save (path)
  "Given PATH (full path and file name) check for newer auto-save file."
  (let* (
         (name (file-name-nondirectory path)) ;; could just pass this in too
         (a-s-name (format "#%s#" name))
         )
    ;; if a-s-path does not exist, this is nil
    (file-newer-than-file-p a-s-name path)
    ))

;;=======
;; boneyard

(defun desktop-read-initialization-old (&optional dirname)
  "Does precisely the same folderol as the desktop-read function,
up to the point where it loads the desktop file: instead it returns the
full name of the desktop file located in DIRNAME."
;; TODO Consider the possibility that "desktop.el" is completely out-to-lunch
;; half of the time, and that slavishly imitating it is bad news, as this
;; routine clearly is.
  (unless noninteractive ;; whole function is a no-op if used interactively...
    (setq desktop-dirname
          (file-name-as-directory
           (expand-file-name
            (or
             ;; If DIRNAME is specified, use it.
             (and (< 0 (length dirname)) dirname)
             ;; Otherwise search desktop file in desktop-path.
             (let ((dirs desktop-path))
               (while (and dirs
                           (not (file-exists-p
                                 (desktop-full-file-name (car dirs)))))
                 (setq dirs (cdr dirs)))
               (and dirs (car dirs)))
             ;; If not found and `desktop-path' is non-nil, use its first element.
             (and desktop-path (car desktop-path))
             ;; Default: Home directory.
             "~"))))
    (if (file-exists-p (desktop-full-file-name))
	;; Desktop file found, but is it already in use?
	(let ((desktop-first-buffer nil)
	      (desktop-buffer-ok-count 0)
	      (desktop-buffer-fail-count 0)
	      (owner (desktop-owner))
	      ;; Avoid desktop saving during evaluation of desktop buffer.
	      (desktop-save nil))
	  (if (and owner
		   (memq desktop-load-locked-desktop '(nil ask))
		   (or (null desktop-load-locked-desktop)
		       (not (y-or-n-p (format "Warning: desktop file appears to be in use by PID %s.\n\
Using it may cause conflicts.  Use it anyway? " owner)))))
	      (let ((default-directory desktop-dirname))
		(setq desktop-dirname nil)
		(run-hooks 'desktop-not-loaded-hook)
		(unless desktop-dirname
		  (message "Desktop file in use; not loaded.")))
	    (desktop-lazy-abort)

            (desktop-full-file-name) ;; TODO question: why not pass in a dirname?
                                     ;; relies on default-directory to pass the value?

            ;; returns the file name (make this clearer?)

	    ))
      ;; No desktop file found.
      (desktop-clear) ;; -- TODO so why are we fucking clearing the desktop?
      (let ((default-directory desktop-dirname))
        (run-hooks 'desktop-no-desktop-file-hook))
      (message "No desktop file.")
      nil)))

;; TODO not yet in use.  (make sure you understand it, eh?)
;; I don't see any need for these features at all, actually...
;; the buffer order juggling is mildly inane (and useless for my purpose)
;; and the detailed report of success or failure is pretty useless...
;; if the file you wanted didn't get opened, you'll just go open it.
(defun desktop-read-tail (&optional dirname)
  "The code that the desktop-read function executes after loading the desktop file.
This folderol was cut and paste from there on the theory that whatever it is
that this is doing it may be a good idea for me to do also."
  (interactive)
  ;;; TODO add anything else here?
  ;;;
  ;; Remember when desktop buffer was modified.
  (setq desktop-file-modtime (nth 5 (file-attributes (desktop-full-file-name))))
  ;; If it wasn't already, mark it as in-use, to bother other
  ;; desktop instances.
  (unless owner
    (condition-case nil
        (desktop-claim-lock)
      (file-error (message "Couldn't record use of desktop file")
                  (sit-for 1))))

  ;; `desktop-create-buffer' puts buffers at end of the buffer list.
  ;; We want buffers existing prior to evaluating the desktop (and
  ;; not reused) to be placed at the end of the buffer list, so we
  ;; move them here.
  (mapc 'bury-buffer
        (nreverse (cdr (memq desktop-first-buffer (nreverse (buffer-list))))))
  (switch-to-buffer (car (buffer-list)))
  (run-hooks 'desktop-delay-hook)
  (setq desktop-delay-hook nil)
  (run-hooks 'desktop-after-read-hook)
  (message "Desktop: %d buffer%s restored%s%s."
           desktop-buffer-ok-count
           (if (= 1 desktop-buffer-ok-count) "" "s")
           (if (< 0 desktop-buffer-fail-count)
               (format ", %d failed to restore" desktop-buffer-fail-count)
             "")
           (if desktop-buffer-args-list
               (format ", %d to restore lazily"
                       (length desktop-buffer-args-list))
             ""))
  )


;;; desktop-recover.el ends here

