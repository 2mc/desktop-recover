;;; desktop-recover.el ---

;; Copyright 2009 Joseph Brenner
;;
;; Author: doom@kzsu.stanford.edu
;; Version: $Id: desktop-recover.el,v 0.0 2009/07/08 02:59:21 doom Exp $
;; Keywords:
;; X-URL: not distributed yet

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, write to the Free Software
;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

;;; Commentary:

;;  Works with the .emacs-desktop files (as generated by desktop.el),
;;  but unlike with desktop-read, provides an interactive menu that
;;  let's the user choose which buffers will be restored.

;; Put this file into your load-path and the following into your ~/.emacs:
;;  (require 'desktop-recover)
;;  ;; optionallly:
;;  (setq desktop-recover-location
;;     (desktop-recover-fixdir "$HOME/.emacs.d/")) ;; ~/.emacs.d is the default
;;  ;; bind a new exit command, so that we can tell if exit was clean.
;;  (define-key ctl-x-map "\C-c" 'desktop-recover-save-buffers-kill-terminal)
;;  ;; And this brings up the interactive buffer restore menu
;;  (desktop-recover-interactive)

;;; Code:

(provide 'desktop-recover)
(eval-when-compile
  (require 'cl))

(require 'desktop)
(require 'thingatpt)

(defconst desktop-recover-version "0.91"
  "The version number of the installed desktop-recover.el package.")



;;======
;; poor man's pod/lazy man's info:
;;   dummy variables with documentation attached

(defvar desktop-recover-toc-doc ""
  "Several variables are defined here just to have a convenient
place to attach documentation strings:\n

`desktop-recover-desktop-doc'
`desktop-recover-philosophy-doc'
`desktop-recover-dangling-buffers-doc'
`desktop-recover-desktop-list-doc'

")

(defvar desktop-recover-desktop-doc ""
  "In this context the \"desktop\" is the emacs desktop, i.e. the
state of all the current buffers that are open at a given moment,
except for the dynamic buffers \(usually named with a leading
asterix\) and a few other odds and ends.  This is the terminology
used by the package \"desktop.el\" \(already standard with GNU
emacs\).  This package, \"desktop-recover.el\", works with
\"desktop.el\", using it for interactive recovery of emacs state
\(e.g. for crash recovery, for people working over flaky network
connections\).  See `desktop-recover-toc-doc'.")

;; it's also likely that this can be used with project-root to
;; implement project-specific desktops.

(defvar desktop-recover-philosophy-doc ""
  "In many respects desktop-recover.el works more simply than desktop.el.
While desktop-recover.el uses desktop.el internally to save the
state of the emacs \"desktop\", it very carefully overrides or
ignores some features. By itself, desktop.el is very cautious
about keeping desktop files locked, so that it can warn the user
if it looks like two different emacs instances are trying to use
the same file.  It also dynamically searches likely locations to
find a desktop file, and it makes it hard to override that
behavior (e.g. just setting the `desktop-dirname' variable
doesn't always work).  This package, desktop-recover.el takes a
somewhat different approach: the presumption is that there is
nothing critical about saving desktop state; it's just a
convenience feature, and so there's nothing important enough
about it to want to bother the user with confirmation.  The
basic desktop-recover save primitive is \\[desktop-recover-force-save]:
it just ignores any desktop.el locks.\n
Also desktop-recover.el uses a much simpler directory search: it
has a single variable that can be set to tell it where to save
to: `desktop-recover-location'.  This defaults to the value of
`user-emacs-directory', which is typically \"~/.emacs.d\".  To
get desktop.el's dynamically determined `desktop-dirname'
behavior, `desktop-recover-location' can be set to nil,\n
In order to supress saves, desktop.el code sets the
`desktop-dirname' to nil, but in contrast, the desktop-recover.el
has the variable `desktop-recover-suppress-save', and also the
function \\[desktop-recover-stop-automatic-saves].\n
See `desktop-recover-toc-doc'.")

(defvar desktop-recover-dangling-buffers-doc ""
  "We use \"dangling buffers\" to mean buffers without associated files.
Typically we will exclude the special display buffers (which
usually begin with an asterix), and possibly dired buffers, and
so on.  We're concerned here with buffers used for temporary
notes that might've been prematurely lost by an emacs crash
\(e.g. due to a broken connection\).\n Along with the automated
desktop save feature, we will save these dangling buffers to
temporary files, making them a little less ephemeral, though not
as permanent as ordinary files.\n Nothing else should be saved to
this special temp directory, because we'll use this location
later to distinguish dangling buffers even after they've been
saved.  This way a clean exit from emacs can skip loading them by default.
See `desktop-recover-toc-doc'.")

(defvar desktop-recover-desktop-list-doc ""
  "Many functions in this package work with a data-structure
typically called the \"desktop-list\". This describes the buffers
recorded in the .emacs-desktop file, which are candidates to be
re-loaded when desktop-recover-interactive is run.  The
desktop-list is a list of lists, with one row per buffer, where
each row is a list of (in this order): name, path, mode, and the
desktop-create-buffer call.  The \"name\" is the name sans path,
the \"path\" is the full-name, including path, the mode is the
name of the associated emacs mode (e.g. \"text-mode\"), and the
\"desktop-create-buffer call\" is the code (in string form) that
will need to be run to restore the buffer.\n
Note, the name \"path\" may be confusing: normally, I would call
this the \"full-name\", but in the case of dired buffers, a
directory is all it is, so we go by the more general name \"path\".
See `desktop-recover-toc-doc'.
")

;;;;##########################################################################
;;;;  User Options, Variables
;;;;##########################################################################

;; defining this first to use it in following defvars, etc.
(defun desktop-recover-fixdir (location &optional root)
  "Fixes up the file directory LOCATION.
Conditions directory paths for portability and robustness.
If the directory does not yet exist, it will be created.\n
Some examples (note, always adds a trailing slash):
 '~/tmp'             => '/home/doom/tmp/'
 '~/tmp/../bin/test' => '/home/bin/test/'\n
Note: converts relative paths to absolute, using the current
default-directory setting, unless specified otherwise with the
ROOT option. As a side-effect: this converts the empty string into
default-directory or ROOT."
  (let ((location
         (substitute-in-file-name
          (convert-standard-filename
           (file-name-as-directory
            (expand-file-name location root))))))
    (unless (file-directory-p location)
      (make-directory location t))
    location))

(defgroup desktop-recover nil
  "Interactive recovery of Emacs status."
  :group 'desktop)

(defcustom desktop-recover-location user-emacs-directory
  "The default location from which we save and restore desktop files.
Defaults to `user-emacs-directory'.  Note: desktop.el has a
`desktop-dirname' variable, but that can not be used reliably as
a user setting, because the code changes it under some
circumstances."
  :type  'directory
  :group 'desktop-recover
)
(put 'desktop-recover-location 'risky-local-variable t)

(defcustom desktop-recover-tmp-dir
  (concat desktop-recover-location "desktop-recover-tmp")
  "Location where dangling buffers that have no associated files are saved."
  :type  'directory
  :group 'desktop-recover
)
(put 'desktop-recover-tmp-dir 'risky-local-variable t)

(defvar desktop-recover-buffer-name "*Desktop Buffer Restore Menu*"
  "Buffer name for the desktop restore menu.")

(defvar desktop-recover-clean-exit-flag "desktop_recover_clean_exit.flag"
  "The existance of a file of this name signals that we did a clean exit.")

(defvar desktop-recover-suppress-save nil
  "Set this to t to over-ride any attempts at doing desktop saves.
Note: this flag is respected by desktop-recover.el code, not desktop.el.")

;; Bound locally in `desktop-read' in desktop.el
(defvar desktop-buffer-ok-count)
(defvar desktop-buffer-fail-count)

(defun desktop-recover-setup ()
  "The usual desktop-recover set-up operations."
  ;; Turning desktop.el off (we use it indirectly)
  (desktop-save-mode -1)
  ;; This sounds good, but does it even do anything?
  (setq desktop-load-locked-desktop t)
  ;; Re-binding, so that we can tell if exit was clean.
  (define-key ctl-x-map "\C-c" 'desktop-recover-save-buffers-kill-terminal)
  ;; Brings up the interactive buffer restore menu
  (desktop-recover-interactive)
  )

;;=======
;; routines common to save/read operations

;; This is used by: desktop-recover-force-save
;; Also: desktop-recover-file-path and hence: desktop-recover-interactive
(defun desktop-recover-location (&optional dirname)
  "The standard behavior for choosing the desktop save location.
If DIRNAME is not given, defaults to `desktop-recover-location'
or the current `desktop-dirname' in that order.
Runs the result through \\[desktop-recover-fixdir], which
does make sure that it will exist. Sets `desktop-dirname' as a side-effect."
  (let* ((location  (desktop-recover-fixdir
                     (or
                      ;; If DIRNAME is given, use it.
                      (and (< 0 (length dirname)) dirname)
                      desktop-recover-location
                      desktop-dirname)))
         )
    (setq desktop-dirname location) ;; makes sure desktop.el knows what we're doing
    ))

;; This is used by: desktop-recover-interactive
(defun desktop-recover-file-path (&optional dirname)
  "Returns the full name and path of the desktop file.
The location is determined by the \\[desktop-recover-location]
function, and the name is determined by the `desktop-base-file-name'
variable.  Typically this will be \"~/.emacs.d/.emacs.desktop\".
This does not check for the existance of the file.
Note: \\[desktop-recover-location] sets `desktop-dirname' as a side-effect."
  (let* ((location (desktop-recover-location dirname))
         (full-name (concat
                      location
                      desktop-base-file-name))
         )
    full-name))

;;---------
;; managing the "clean save flag file"

(defun desktop-recover-flag-clean-exit ()
  "Create the file that indicates that we're doing a clean exit.
Actually, it flags the fact that we *tried* to exit cleanly, since
there's no easy way to check if all saves were completed before
emacs died."
  (interactive)
  (let* ((clean-exit-flag-file
           (concat
            (desktop-recover-fixdir
             desktop-recover-tmp-dir)
            desktop-recover-clean-exit-flag))
         )
    (save-excursion
      (find-file clean-exit-flag-file)
      (insert " ")
      (save-buffer)
      )))

(defun desktop-recover-reset-clean-exit-flag ()
  "Erase the file used to flag that emacs exited cleanly."
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         )
         (if (file-exists-p clean-exit-flag-file)
             (delete-file clean-exit-flag-file)
             )
    ))

(defun desktop-recover-clean-exit-p ()
  "Does it look like emacs exited cleanly?"
  (let* (
         (tmp-dir (desktop-recover-fixdir
                   desktop-recover-tmp-dir))
         (clean-exit-flag-file
          (concat tmp-dir desktop-recover-clean-exit-flag))
         (retval (file-exists-p clean-exit-flag-file))
         )
    retval))

;;======================
;; saving desktop files (with dangler management)
(defun desktop-recover-do-saves-automatically ()
  "Makes the desktop saved automatically using the auto-save-hook."
  (add-hook 'auto-save-hook 'desktop-recover-save-with-danglers))

(defun desktop-recover-stop-automatic-saves ()
  "Stops the desktop from being saved automatically via the auto-save-hook."
  (remove-hook 'auto-save-hook 'desktop-recover-save-with-danglers))

(defun desktop-recover-save-buffers-kill-terminal ()
  "For doing a \"clean\" exit.
Essentially a wrapper around save-buffers-kill-terminal.
This is intended to be bound to the usual keybinding for exiting emacs."
  (interactive)
  (desktop-recover-stop-automatic-saves)
  (desktop-recover-save-with-danglers)
  (desktop-recover-flag-clean-exit)
  (save-buffers-kill-terminal)
  )

(defun desktop-recover-save-with-danglers ()
  "Save desktop preserving buffers that have no associated files.
Works by saving these danglers to a standard tmp directory, then
lets desktop.el save them along with the other open files.  After
re-starting emacs, you should then have buffers corresponding to
the old dangling buffers (though now they'll be associated with
files in the tmp location).  See: `desktop-recover-dangling-buffers-doc'"
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (temp-loc
          (desktop-recover-fixdir desktop-recover-tmp-dir))
         (dangling-buffers (desktop-recover-list-dangling-buffers))
         )
    (unless (file-exists-p temp-loc)
      (make-directory temp-loc t))
    ;; save all to temp location using a file name identical to the buffer name
    (dolist (buffy dangling-buffers)
            (set-buffer buffy)
            (let* ((buffy-name (buffer-name  buffy))
                   (file-nameo (concat temp-loc "/" buffy-name))
                   )
              (write-file file-nameo)
              ))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
    (desktop-recover-force-save)
  ))

;; Note: used by desktop-recover-save-with-danglers
(defun desktop-recover-list-dangling-buffers ()
  "List buffers without files or directories, skipping internal and display buffers.
Returns a list of buffer objects."
  (interactive)
  (save-excursion
  (let* ((initial-buffer (current-buffer))
         (ordinaries-list (desktop-recover-list-ordinary-buffers))
         (output-list)
         )
    (save-excursion
      (dolist (buffy ordinaries-list)
        (set-buffer buffy) ;; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy) )
               (buffy-name (buffer-name  buffy) )
               )
          (cond ((not file-nameo) ;; looking for buffers without file names
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer initial-buffer)
      (deactivate-mark)
  output-list))))

;; Note: used by desktop-recover-list-dangling-buffers
;; and hence by desktop-recover-save-with-danglers
(defun desktop-recover-list-ordinary-buffers ()
  "List buffers, skips: dired, shell, debugger, internal and display buffers.
Returns a list of buffer objects.  Note that 'ordinary' buffers include
'dangling' buffers without associated files."
  (interactive)
  (let* ((initial-buffer (current-buffer))
         (output-list)
         )
    (save-excursion
      (dolist (buffy (buffer-list))
        (set-buffer buffy) ; switch to buffer so we can check 'major-mode'
        (let* ((file-nameo (buffer-file-name buffy))
               (buffy-name (buffer-name buffy))
               )
          (cond ((and
                  ;; Skip directories
                  (not (string= major-mode "dired-mode"))
                  ;; Skip internal buffers (begin with space)
                  (not (string= (substring buffy-name 0 1) " "))
                  ;; Skip dynamic display buffers (begin with asterix)
                  (not (string= (substring buffy-name 0 1) "*"))
                  ;; Skip shell and debugger buffers (even without leading "*")
                  (not (or
                        (string= major-mode "shell-mode")
                        (string= major-mode "eshell-mode")
                        (string= major-mode "gud-mode")))
                  ;; Skip the desktop file itself
                  (not (string= file-nameo (desktop-recover-file-path)))
                  )
                 (push buffy output-list)
                 )
                )))
      (switch-to-buffer initial-buffer)
      (deactivate-mark)
      output-list)))

;; currently, this is not used directly by desktop-recover.el
(defun desktop-recover-break-file-association-of-danglers ()
  "Remove association between dangling buffers and temp files.
We can distinguish between \"real\" buffers and ones that are
dangling-but-saved by the fact that they've been saved to
`desktop-recover-tmp-dir'. See `desktop-recover-dangling-buffers-doc'."
  (interactive)
  (let* ((preserve-buffer (current-buffer))
         (temp-loc (desktop-recover-fixdir desktop-recover-tmp-dir))
         (buffers (desktop-recover-list-ordinary-buffers))
              ;; includes real danglers, as well as saved ones
         (location)
         (dangling-content-list)
              ;; list of lists: buffer name paired with content
         )
    ;; breaking file associations of any buffers saved to temp-loc
    (dolist (buffy buffers)
      (setq location (file-name-directory (buffer-file-name buffy)))
      (cond ((string= temp-loc location)
             (set-buffer buffy)
             (let ((name (buffer-name)))
               (set-visited-file-name nil)
               ;; (rename-buffer name) ;; doesn't seem to be necessary
               )
             )))
    (switch-to-buffer preserve-buffer)
    (deactivate-mark)
  ))

(defun desktop-recover-save-without-danglers ()
  "Desktop autosave routine that skips dangling buffers of any vintage.
This means that it screens out the ones that have been made less ephemeral
by associating them with files in the standard tmp directory.
See: `desktop-recover-dangling-buffers-doc'"
  (interactive)
  (desktop-recover-break-file-association-of-danglers)
  (desktop-recover-force-save))

;; --------
;; desktop-recover.el save primitives (all other "saves" use these internally)

(defun desktop-recover-force-save (&optional dirname release)
   "Force save of desktop by wiping out any existing file first.
This ensures you will not have any questions getting in the way
about modification times, etc.  If DIRNAME is not given, defaults
to `desktop-recover-location' or the current `desktop-dirname' in
that order.  Passes through RELEASE to \\[desktop-save],
which if t means \"we're done with this desktop\"."
;; Essentially, setting RELEASE deletes the lock file.
;; Should I just do that all the time?
   (let* ((location (desktop-recover-location dirname))
          )
     (cond ((not desktop-recover-suppress-save)
            (setq desktop-dirname (file-name-as-directory (expand-file-name location)))
            (desktop-remove)
            (desktop-save location release)
            )
           (t
            (message "Desktop save skipped, because desktop-recover-suppress-save is set"))
           )))

;;--------
;; window management utilities

(defun desktop-recover-buffer-safe-to-overwrite-p (buffer-name)
  "Verify that a buffer is safe to be over-written.
Currently this is just a check to make sure the given name
follows the convention for dynamic display buffers: it must
begin with a leading asterix."
  (string= (substring buffer-name 0 1) "*"))

;; not currently in use
(defun desktop-recover-list-in-other-window (list buffer-name)
  "Displays LIST of strings in BUFFER-NAME in a second window.
Closes all other windows except for the current window and the
newly created one."
  (unless
      (desktop-recover-buffer-safe-to-overwrite-p buffer-name)
    (error (format "%s does not look safe to over-write." buffer-name)))
  (delete-other-windows)
  (split-window-vertically)
  (other-window 1)
  (switch-to-buffer buffer-name)
  (mark-whole-buffer)
  (delete-region (mark) (point))
  (insert (mapconcat 'identity list "\n"))
  (deactivate-mark))

;;======================
;; read desktop files

;; desktop.el just loads the .emacs-desktop files (which are elisp code)
;; I want to deal with each file conditionally, so I need to parse it myself
(defun desktop-recover-interactive (&optional dirname)
  "Read the .emacs-desktop file, bring up menu to approve buffer restoration."
  (interactive "Dload desktop file from:")
  (desktop-save-mode -1) ;; Turning desktop.el off (we'll use it indirectly)
  (setq desktop-load-locked-desktop t) ;; Sounds good. Does it do anything?
  (let* ((desktop-file (desktop-recover-file-path dirname))
         ;; an .emacs-desktop file is in sections labeled like so:
         (global-section-marker ";; Global section")
         (buffer-section-marker ";; Buffer section")
         ;; prepend ^ to make them regexps
         (global-section-pattern
          (concat "^" global-section-marker))
         (buffer-section-pattern
          (concat "^" buffer-section-marker))
         (global-section "")
         (buffer-section "")
         (desktop-list)  ;; list of lists, one row for each desktop buffer
         )
    (cond ((file-exists-p desktop-file)
           (find-file desktop-file)
           ;; parse into global and buffer sections
           ;; TODO also need to check the file format version: warn if it's wrong.
           (goto-char (point-min))
           (re-search-forward global-section-pattern)
           (forward-line 1)
           (let* ((beg (point) )
                  (end))
             (re-search-forward buffer-section-pattern)
             (previous-line 1)
             (move-end-of-line 1)
             (setq end (point))
             (setq global-section (buffer-substring-no-properties beg end)))
           (forward-line 2)
           (let* ((beg (point) )
                  (end (point-max)))
             (setq buffer-section (buffer-substring-no-properties beg end)))
           (eval (read global-section))
           (setq desktop-list
                 (desktop-parse-buffer-section buffer-section))
           ;; display the desktop-list in an interactive selection buffer
           (desktop-recover-show-menu desktop-list)
           )
          (t
           (desktop-recover-do-saves-automatically))
          )
    ))

(defun desktop-parse-buffer-section (buffer-section)
  "Associate file system names with desktop-create-buffer code.
Parses the 'buffer section' of a .emacs.desktop file (passed in
as the string BUFFER-SECTION) subdividing it into
desktop-create-buffer function calls, and picking out names from
them to use for user confirmation.  Returns the desktop-list, a
list of lists, with one row per buffer, where each row is a
list (in this order) of: name, path, mode, and the
desktop-create-buffer call.  See \\[desktop-recover-desktop-list-doc]."
;;  (interactive) ;; DEBUG only
  (let* ((dcb-string "(desktop-create-buffer")
         (dcb-pattern (format "^[ \t]*?%s[ \t]" dcb-string))
         (dcb-list)
         (dcb-lines)
         (file-format)
         (mode)
         (file-name)  ;; full name, with path
         (name)       ;; file/dir name without path
         (misc)       ;; a list of stuff... multiple paths for tree dired?
         (first-misc) ;; the primary dir in dired-mode (with trailing slash)
         (path)
         (record)
         (desktop-list)
         )
    ;; here we split on the initial funcall string, then prepend it again
    ;; to have the list of complete function calls
    (setq dcb-list
          (mapcar (lambda (item)
                    (concat dcb-string " "
                            (substring-no-properties item)))
                  (split-string buffer-section dcb-pattern t)))
    (dolist (dcb-code dcb-list)
      ;; parse dcb-code as a list
      (setq dcb-lines (split-string dcb-code "\n" t))
      ;;
      (setq file-format (car (cdr (split-string (nth 0 dcb-lines) " " t))))
      (setq file-name (desktop-recover-clean-string (nth 1 dcb-lines)))
      (setq name (desktop-recover-clean-string (nth 2 dcb-lines)))
      (setq mode (desktop-recover-clean-string (nth 3 dcb-lines)))
      (setq misc (nth 8 dcb-lines))  ;; will need extra clean?
      ;;
      (cond ((string= mode "dired-mode")
             (setq first-misc (desktop-recover-snag-first-item misc))
             (setq path first-misc))
            (t
             (setq path file-name)
             ))
      (setq record
            (append
             (mapcar 'eval
                     '(name path mode dcb-code))
             record))
      (setq desktop-list (cons record desktop-list))
      )
    desktop-list))

(defun desktop-recover-clean-string (string)
  "Do some common quick-and-dirty string clean-up operations.
Strips leading/trailing whitespace, bracketing double-quotes, and
also any leading single-quotes."
  (let ((strip-lead-space-pattern      "^[ \t]*\\([^ \t]*.*\\)" )
        (strip-trail-space-pattern     "\\(.*?\\)[ \t]*$"       )
        (strip-lead-apostrophe-pattern "^'*\\(.*\\)"            )
        (strip-lead-quote-pattern      "^\"*\\(.*\\)")
        (strip-trail-quote-pattern     "\\(.*?\\)\"*$")
        )
    (setq string
          (cond ((string-match strip-lead-space-pattern string)
                 (match-string 1 string))
                (t
                 string)))
    (setq string
          (cond ((string-match strip-trail-space-pattern string)
                 (match-string 1 string))
                (t
                 string)))
    (setq string
          (cond ((string-match strip-lead-apostrophe-pattern string)
                 (match-string 1 string))
                (t
                 string)))
    (setq string
          (cond ((string-match strip-lead-quote-pattern string)
                 (match-string 1 string))
                (t
                 string)))
    (setq string
          (cond ((string-match strip-trail-quote-pattern string)
                 (match-string 1 string))
                (t
                 string)))
    string))

(defun desktop-recover-snag-first-item (list-string)
  "Get's the first item out of the list stored in LIST-STRING.
Intended to deal with the 'desktop-buffer-misc' field of a desktop-create-buffer call.
Which may look something like:
  '(\"/home/doom/End/Pit/\")
Note: This is not just a wrapper around \"car\", it does the
conversion from string to list first."
  (let* ((list (eval (read list-string)))
         (first-item (car list))
         )
    first-item))

;;========
;; interactive menu for selecting what to recover

;; Display a list of marker, name, path, mode,
;; where the marker is set ("*") if buffer is to be loaded,
;; The return key is the "do-it" that accepts the displayed settings,
;; and the "m" and "u" keys control whether the current line is set

(defgroup desktop-recover-faces nil
  "Typefaces used in the interactive desktop-recover menu."
  :group 'desktop-recover
  :group 'faces)

(defface desktop-recover-directory-face
  '((((class color)
      (background light))
     (:foreground "Navy" :bold t))
    (((class color)
      (background dark))
     (:foreground "LightBlue" :bold t))
    (t
     (:bold t)))
  "Face used for displaying dired buffer entires in desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-heading-face
  '((((class color)
      (background light))
     (:foreground "black"))
    (((class color)
      (background dark))
     (:foreground "white")))
  "Face used for displaying the heading of the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-perl-face
  '((((class color)
      (background light))
     (:foreground "olive drab"))
    (((class color)
      (background dark))
     (:foreground "light green")))
  "Face used for displaying perl buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-sh-face
  '((((class color)
      (background light))
     (:foreground "dark orchid"))
    (((class color)
      (background dark))
     (:foreground "orchid")))
  "Face used for displaying sh buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-a-to-d-face
  '((((class color)
      (background light))
     (:foreground "dark slate blue"))
    (((class color)
      (background dark))
     (:foreground "light slate blue")))
  "Face used for displaying sh buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-e-to-j-face
  '((((class color)
      (background light))
     (:foreground "maroon4"))
    (((class color)
      (background dark))
     (:foreground "maroon1")))
  "Face used for displaying sh buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-k-to-q-face
  '((((class color)
      (background light))
     (:foreground "RoyalBlue4"))
    (((class color)
      (background dark))
     (:foreground "RoyalBlue1")))
  "Face used for displaying sh buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-r-to-s-face
  '((((class color)
      (background light))
     (:foreground "aquamarine4"))
    (((class color)
      (background dark))
     (:foreground "aquamarine1")))
  "Face used for displaying sh buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defface desktop-recover-t-to-z-face
  '((((class color)
      (background light))
     (:foreground "PaleVioletRed4"))
    (((class color)
      (background dark))
     (:foreground "PaleVioletRed1")))
  "Face used for displaying sh buffer entries in the desktop-recover menu."
  :group 'desktop-recover-faces)

(defvar desktop-recover-marker "*"
  "Symbol used to show a buffer will be reloaded \(typically \"*\"\).")

(defvar desktop-recover-auto-save-marker "#"
  "Symbol used to show that a more recent auto-save file exists \(typically \"#\"\).")

(defvar desktop-recover-unmarker " "
  "Character used to erase either of the above markers (typically a space).")

;;--------
;; the view: display the info about buffers which may be re-loaded

(defun desktop-recover-build-menu-contents (desktop-list)
  "Builds the menu text from the DESKTOP-LIST data."
  (let* ((name) (path) (mode) (dcb-code)
        (marker desktop-recover-marker)     ;; "*"
        (unmarker desktop-recover-unmarker) ;; " "
        (auto-save-mark desktop-recover-auto-save-marker) ;; "#"
        (line "")
        ;; (line-fmt " %1s %-33s%-42s %1s")
        (line-fmt (desktop-recover-menu-format desktop-list))
        (marker-field)
        (auto-save-field)
        (hint-mess (concat
                    "To open indicated buffers: RETURN. "
                    "Mark: \"*\" Unmark: \"u\" "
                    "Toggle auto-save: \"#\"" "\n"))
        (menu-contents "")
        )
    ;; colorize the heading line
    (put-text-property 0 (length hint-mess)
                       'face 'desktop-recover-heading-face
                       hint-mess)
    (setq menu-contents hint-mess)
    (dolist (record desktop-list)
      ;; unpack the record
      (setq name     (nth 0 record))
      (setq path     (nth 1 record))
      (setq mode     (nth 2 record))
      (setq dcb-code (nth 3 record))
      (setq marker-field
            (cond ((desktop-recover-by-default-p record)
                   desktop-recover-marker)
                  (t
                   desktop-recover-unmarker)
                  ))
      (setq auto-save-field
            (cond ((desktop-recover-newer-auto-save path)
                   auto-save-mark)
                  (t
                   desktop-recover-unmarker)
                  ))
      (let ((visible-path path)
            (visible-name name)
            )
        (cond (;; looks like a directory
               (string= mode "dired-mode")
               (setq visible-path
                     (replace-regexp-in-string "/$" "" visible-path))
               )
              (t ;; not a directory
               (setq visible-path (file-name-directory path))
               ))
        (setq visible-path
              (replace-regexp-in-string
               (concat "^" (getenv "HOME"))
               "~" visible-path))
        (setq visible-path (desktop-recover-choose-faces visible-path mode))
        (setq visible-name (desktop-recover-choose-faces visible-name mode))
        (setq line (format
                    line-fmt
                    marker-field
                    auto-save-field
                    visible-name
                    visible-path
                    )))
      ;; saving the dcb code block out-of-sight, attached to first character
      (put-text-property 0 1 'dcb dcb-code line)
      ;; preserving all the visible fields also
      (put-text-property 0 1 'name name line)
      (put-text-property 0 1 'path path line)
      (put-text-property 0 1 'mode mode line)
      (put-text-property 0 1 'marker marker-field line)
      (put-text-property 0 1 'auto-save auto-save-field line)
      (setq menu-contents
            (concat menu-contents line "\n")
      ))
    menu-contents))

(defun desktop-recover-choose-faces (string mode)
  "Choose an appropriate face for STRING, given the MODE name.
Some modes are special cases with particular faces associated
with them, for the others, we look at the first character
of the mode name, and use it to choose a more generic face."
  (cond ((string= mode "dired-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-directory-face
                            string))
        ((string-match "^[c]*perl-mode$" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-perl-face
                            string))
        ((string= mode "sh-mode")
         (put-text-property 0 (length string)
                            'face 'desktop-recover-sh-face
                            string))
        ((string-match "^[a-d]" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-a-to-d-face
                            string))
        ((string-match "^[e-j]" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-e-to-j-face
                            string))
        ((string-match "^[k-q]" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-k-to-q-face
                            string))
        ((string-match "^[r-s]" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-r-to-s-face
                            string))
        ((string-match "^[t-z]" mode)
         (put-text-property 0 (length string)
                            'face 'desktop-recover-t-to-z-face
                            string)))
  string)


;; four fields: marker auto-save-marker name  path
(defun desktop-recover-menu-format (desktop-list)
  "Choose the menu format, balancing between lengths of name and path."
  (let* ((name) (path) (width-name) (width-path)
         (total-width (frame-width))
         (max-name 0)
         ;; (max-path 0)    ;; Not making any use of max-path at present
         (line-fmt "")
         )
    (dolist (record desktop-list)
      (setq name     (nth 0 record))
      (setq path     (nth 1 record))
      (if (> (length name) max-name)
          (setq max-name (length name)))
      ;; (if (> (length path) max-path)
      ;; (setq max-path (length path)))
        )
    ;; Goal: (line-fmt " %1s %1s %-33s%-42s")
    (setq width-name (+ max-name 2))
    (setq width-path (- total-width 6 width-name))
    (setq line-fmt
          (concat
           " %1s %1s %-"
           (number-to-string width-name)
           "s%-"
           (number-to-string width-path)
           "s"))
    line-fmt))

;; TODO this has access to the mode -- why not use it?
;; could distinguish between dired & shell buffers at this stage?
;; might be good to do dynamic buffer filtering later than I am...
(defun desktop-recover-by-default-p (record)
  "Examine RECORD to determine if this buffer should be reloaded by default.
A file should not be re-loaded if was an automatically saved temporary
buffer and emacs exited cleanly.  RECORD should be a list of
name, path, mode and dcb-code."
  (let* ((tmp-dir (desktop-recover-fixdir desktop-recover-tmp-dir))
         ;; unpack the record
         (name     (nth 0 record))
         (path     (nth 1 record)) ;; eval don't do trick.  properties prob? TODO
         (mode     (nth 2 record))
         (dcb-code (nth 3 record))
         (location  (desktop-recover-fixdir (file-name-directory path)))
         ;; return value
         (recover-p
          (cond ((string= location tmp-dir) ;; this is a preserved dangler
                 (cond ((desktop-recover-clean-exit-p)
                        nil)
                       (t
                        t)))
                (t t)))
         )
    recover-p))

(defun desktop-recover-newer-auto-save (path)
  "Given PATH (full path and file name) check for newer auto-save file."
  (let* (
         (path (desktop-recover-clean-string path))
         (name (file-name-nondirectory path)) ;; could just pass this in also
         (loc  (file-name-directory path))
         (a-s-name (format "#%s#" name))
         (auto-save (concat loc a-s-name))
         )
    ;; if autosave does not exist, this is nil
    (file-newer-than-file-p auto-save path)
    ))

;;--------
;; the controller: a simple mode to handle selection of buffers to be restored.

(define-derived-mode desktop-recover-mode
  text-mode "desktop-recover"
  "Major mode to display candidates for buffers to be restored when re-starting emacs.
\\{desktop-recover-mode-map}"
  (use-local-map desktop-recover-mode-map)
  )

(define-key desktop-recover-mode-map "\C-m" 'desktop-recover-do-it)
(define-key desktop-recover-mode-map "m"  'desktop-recover-mark-move-down)
(define-key desktop-recover-mode-map "u"  'desktop-recover-unmark-move-down)
(define-key desktop-recover-mode-map "n"  'next-line)
(define-key desktop-recover-mode-map "p"  'previous-line)
(define-key desktop-recover-mode-map "*"  'desktop-recover-mark-move-down)
(define-key desktop-recover-mode-map "#"  'desktop-recover-toggle-hash-move-down)

(defun desktop-recover-do-it ()
  "Accept the current settings of the restore menu buffer.
Runs the appropriate \"desktop-create-buffer\" calls stored
in the desktop-list data structure.  Follows up
with auto-save file recovery, if that's indicated."
  (interactive)
  (let* (
         (recover-list-buffer (current-buffer))
         (desktop-recover-suppress-save t) ;; Don't save desktop during load
         (marker-pattern
          (concat "^[ \t]"
                  desktop-recover-marker
                  "\\*")) ;; line begins with asterix
         (auto-save-pattern desktop-recover-auto-save-marker)
         (line-count (count-lines (point-min) (point-max)))
         ;; saving the file the cursor is pointing at
         (current-name (get-char-property (point) 'name))
         (current-path (get-char-property (point) 'path))
         ;;
         )
    (goto-char (point-min))
    (while ;; loop over all lines in buffer
        (progn
          (save-excursion
            (move-beginning-of-line 1)
            ;; if line is marked with an asterix...
            (cond ((thing-at-point-looking-at marker-pattern)
                   (let*
                       (
                        ;; unpacking info stashed in 1st char properties
                        (dcb-code  (eval (get-char-property (point) 'dcb)))
                        (auto-save (get-char-property (point) 'auto-save))
                        ;; (mode (eval (get-char-property (point) 'mode)))
                        (name (get-char-property (point) 'name))
                        (path (get-char-property (point) 'path))
                        ;; must imitate the context of dcb calls in desktop.el
                        ;; (even though we don't care about these features).
                        (desktop-first-buffer nil)
                        (desktop-buffer-ok-count 0)
                        (desktop-buffer-fail-count 0)
                        (owner (desktop-owner))
                        )
                     ;; do it to it
                     (eval (read dcb-code))
                     (cond ((not (string-match "/$" path)) ;; not a directory
                            ;; check for auto-save file, recover if indicated
                            (cond ((and
                                    (desktop-recover-newer-auto-save path)
                                    (string-match auto-save-pattern auto-save))
                                   (desktop-recover-recover-file path)
                                   ))
                            ))
                     )))
            ) ;; end save-excursion
          ;; (set-buffer recover-list-buffer) ;; do you *trust* save-excursion?
          (forward-line 1)
          (<= (line-number-at-pos) line-count))) ;; end while-progn
    (desktop-recover-do-saves-automatically)
    ;; bring current-path to the fore, then show (list-buffers)
    (if current-path
        (find-file current-path))
    (list-buffers)
    ))

(defun desktop-recover-mark ()
  "Set the marker for the current line: add leading asterix."
  ;; TODO hard to avoid hardcoding column 2 presumption, right?
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-marker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-unmark ()
  "Unset the marker for the current line: remove leading asterix."
  ;; TODO better to search for the asterix, no?  This assumes it's in col 2.
  (interactive)
  (save-excursion
  (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (forward-char 1)
    (delete-char 1)
    (insert desktop-recover-unmarker)
    (setq overwrite-mode nil)
    (setq buffer-read-only 't)
  ))

(defun desktop-recover-mark-move-down ()
  "Set marker on the current line, move down one."
  (interactive)
  (desktop-recover-mark)
  (forward-line 1))

(defun desktop-recover-unmark-move-down ()
  "Unset marker of the current line, move down one."
  (interactive)
  (desktop-recover-unmark)
  (forward-line 1))

;; This is intended to be run at emacs init time (run from
;; desktop-recover-interactive) so there's no need for a keybinding
(defun desktop-recover-show-menu (desktop-list)
  "Displays info about buffers that are candidates to be restored.
These are buffers that existed when the last desktop save was done."
  (interactive)
  (let* ((menu-contents))
    (setq menu-contents (desktop-recover-build-menu-contents desktop-list))
    (switch-to-buffer desktop-recover-buffer-name)
    (setq buffer-read-only nil)
    (delete-region (point-min) (point-max))
    (insert menu-contents)
    (forward-line 1)
    (desktop-recover-mode)
    (setq buffer-read-only 't)
  )
  ;; after recovery, remove flag file (re-created by doing a clean exit)
  (desktop-recover-reset-clean-exit-flag)
  ;; make sure auto desktop saves don't happen until after recovery.
  (desktop-recover-stop-automatic-saves)
  )

(defun desktop-recover-toggle-hash ()
  "Toggle the auto-save \(\"#\"\) marker for the current line.
Will not turn this mark on unless there really is a newer auto-save file."
  (interactive)
  (save-excursion
    (setq buffer-read-only nil)
    (move-beginning-of-line 1)
    (let* (;; unpacking info stashed in 1st char properties
           (status (eval (get-char-property (point) 'auto-save)))
           ;; (dcb-code  (eval (get-char-property (point) 'dcb)))
           ;; (mode (eval (get-char-property (point) 'mode)))
           (name (eval (get-char-property (point) 'name)))
           (path (eval (get-char-property (point) 'path)))
           )
      (cond ((string= status desktop-recover-auto-save-marker)
             ;; search for hash mark
             (search-forward desktop-recover-auto-save-marker)
             (backward-char 1)
             ;; replace with desktop-recover-unmarker
             (delete-char 1)
             (insert desktop-recover-unmarker)
             ;; modify text property
             (setq status desktop-recover-unmarker)
             (move-beginning-of-line 1)
             (put-text-property (point) (1+ (point)) 'auto-save status)
             )
            ((and
              (string= status desktop-recover-unmarker)
              (desktop-recover-newer-auto-save path))
             ;; step to hash marker field (no easy way to avoid hardcoding)
             (forward-char 3)
             ;; replace with desktop-recover-auto-save-marker
             (delete-char 1)
             (insert desktop-recover-auto-save-marker)
             ;; modify text property
             (setq status desktop-recover-auto-save-marker)
             (move-beginning-of-line 1)
             (put-text-property (point) (1+ (point)) 'auto-save status)
             ))
      (setq overwrite-mode nil)
      (setq buffer-read-only 't)
      )))

(defun desktop-recover-toggle-hash-move-down ()
  "Set marker on the current line, move down one."
  (interactive)
  (desktop-recover-toggle-hash)
  (forward-line 1))


;;=======
;; recover-file *quietly*

;; Sleazy cut-and paste of a routine from files.el, so that
;; I can yank out the "Recover auto save file" question.
(defun desktop-recover-recover-file (file)
  "Visit file FILE, but get contents from its last auto-save file.
This bears an amazing resemblence to recover-file from files.el.
It does almost precisely the same thing, but it shuts up about it."
  ;; Actually putting the file name in the minibuffer should be used
  ;; only rarely.
  ;; Not just because users often use the default.
  (interactive "FRecover file: ")
  (setq file (expand-file-name file))
  (if (auto-save-file-name-p (file-name-nondirectory file))
      (error "%s is an auto-save file" (abbreviate-file-name file)))
  (let ((file-name (let ((buffer-file-name file))
		     (make-auto-save-file-name))))
    (cond ((if (file-exists-p file)
	       (not (file-newer-than-file-p file-name file))
	     (not (file-exists-p file-name)))
	   (error "Auto-save file %s not current"
		  (abbreviate-file-name file-name)))
	  (t ;; desktop-recover always does this without question
           (save-window-excursion
	     (with-output-to-temp-buffer "*Directory*"
	       (buffer-disable-undo standard-output)
	       (save-excursion
		 (let ((switches dired-listing-switches))
		   (if (file-symlink-p file)
		       (setq switches (concat switches "L")))
		   (set-buffer standard-output)
		   ;; Use insert-directory-safely, not insert-directory,
		   ;; because these files might not exist.  In particular,
		   ;; FILE might not exist if the auto-save file was for
		   ;; a buffer that didn't visit a file, such as "*mail*".
		   ;; The code in v20.x called `ls' directly, so we need
		   ;; to emulate what `ls' did in that case.
		   (insert-directory-safely file switches)
		   (insert-directory-safely file-name switches))))
	     ;; (yes-or-no-p (format "Recover auto save file %s? " file-name))
             )
	   (switch-to-buffer (find-file-noselect file t))
	   (let ((inhibit-read-only t)
		 ;; Keep the current buffer-file-coding-system.
		 (coding-system buffer-file-coding-system)
		 ;; Auto-saved file should be read with special coding.
		 (coding-system-for-read 'auto-save-coding))
	     (erase-buffer)
	     (insert-file-contents file-name nil)
	     (set-buffer-file-coding-system coding-system))
	   (after-find-file nil nil t))
	  ;; (t (error "Recover-file cancelled"))
          )))

;;; desktop-recover.el ends here

